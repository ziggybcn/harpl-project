
#include "main.h"

//${CONFIG_BEGIN}
#define CFG_CONFIG debug
#define CFG_CPP_DOUBLE_PRECISION_FLOATS 1
#define CFG_CPP_INCREMENTAL_GC 1
#define CFG_DEBUG 1
#define CFG_HOST winnt
#define CFG_LANG cpp
#define CFG_PARSER_FUNC_ATTRS 0
#define CFG_REFLECTION_FILTER stdio
#define CFG_TARGET stdcpp
//${CONFIG_END}

//${TRANSCODE_BEGIN}

// C++ Monkey runtime.
//
// Placed into the public domain 24/02/2011.
// No warranty implied; use at your own risk.

/*
#include <cmath>
#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <typeinfo>
#include <signal.h>
#if _WIN32
#include <windows.h>
#endif
*/

#if CFG_CPP_DOUBLE_PRECISION_FLOATS
typedef double Float;
#define FLOAT(X) X
#else
typedef float Float;
#define FLOAT(X) X##f
#endif

//***** GC Config *****

//#define CFG_CPP_DEBUG_GC 1

#if CFG_CPP_DEBUG_GC
#if __APPLE__
#define DEBUG_GC_MAC 1
#elif defined( __glfw_h_ )
#define DEBUG_GC_GLFW 1
#else
#undef DEBUG_GC
#endif
#endif

//***** Simple profiler *****

#if PROFILE

#include <mmsystem.h>
#include <map>
#include <algorithm>

DWORD profTimer;
CRITICAL_SECTION profLock;
std::vector<const char*> profStack;
std::map<const char*,int> profTicksLocal;
std::map<const char*,int> profTicksTotal;

void profEnter( const char *p ){
	EnterCriticalSection( &profLock );
	profStack.push_back( p );
	LeaveCriticalSection( &profLock );
}

void profLeave(){
	EnterCriticalSection( &profLock );
	profStack.pop_back();
	LeaveCriticalSection( &profLock );
}

void CALLBACK profTimerTick( UINT uTimerID,UINT uMsg,DWORD dwUser,DWORD dw1,DWORD dw2 ){
	EnterCriticalSection( &profLock );
	if( profStack.size() ){
		++profTicksLocal[profStack.back()];
		for( int i=0;i<profStack.size();++i ){
			++profTicksTotal[ profStack[i] ];
		}
	}
	LeaveCriticalSection( &profLock );
}

void profStart(){
	InitializeCriticalSection( &profLock );
	profTimer=timeSetEvent( 5,0,profTimerTick,0,TIME_PERIODIC|TIME_CALLBACK_FUNCTION );//	|TIME_KILL_SYNCHRONOUS );
}

struct ProfInfo{
	int n;
	const char *p;
	ProfInfo( int n,const char *p ):n(n),p(p){
	}
	bool operator<( const ProfInfo &i )const{
		return n>i.n;
	}
};

void profDump( const std::map<const char*,int> &ticks ){
	std::vector<ProfInfo> infos;
	int sum=0;
	for( std::map<const char*,int>::const_iterator it=ticks.begin();it!=ticks.end();++it ){
		const char *p=(*it).first;
		int n=(*it).second;
		sum+=n;
		infos.push_back( ProfInfo( n,p ) );
	}
	std::sort( infos.begin(),infos.end() );
	for( int i=0;i<infos.size();++i ){
		int t=infos[i].n*10000/sum;
		printf( "%i.%i%% : %s\n",t/100,t%100,infos[i].p );
	}
}

void profStop(){
	timeKillEvent( profTimer );

	EnterCriticalSection( &profLock );

	printf( "\nLocal:\n" );
	profDump( profTicksLocal );

	printf( "\nTotal:\n" );
	profDump( profTicksTotal );

	fflush( stdout );

	LeaveCriticalSection( &profLock );
}

#define P_START profStart();
#define P_STOP profStop();
#define P_ENTER(X) profEnter( X );
#define P_LEAVE profLeave();

#else

#define P_START
#define P_STOP
#define P_ENTER(X)
#define P_LEAVE

#endif

// ***** GC *****

#if DEBUG_GC_MAC
#include <mach/mach_time.h>
int gcMicros(){
	static uint64_t startTime;
	static mach_timebase_info_data_t timeInfo;
	if( !startTime ){
		startTime=mach_absolute_time();
		mach_timebase_info( &timeInfo );
	}
	uint64_t nanos=mach_absolute_time()-startTime;
	nanos*=timeInfo.numer;
	nanos/=timeInfo.denom;
	return nanos/1000L;
}
#endif

#if DEBUG_GC_GLFW
int gcMicros(){
	return glfwGetTime()*1000000;
}
#endif

struct gc_object;

gc_object *gc_malloc( int size );
void gc_free( gc_object *p );

struct gc_object{
	gc_object *succ;
	int flags;
	
	virtual ~gc_object(){
	}
	
	virtual void mark(){
	}
	
	void *operator new( size_t size ){
		return gc_malloc( size );
	}
	
	void operator delete( void *p ){
		gc_free( (gc_object*)p );
	}
};

//alloced objs
gc_object *gc_objs;

//fast alloc cache
gc_object *gc_cache[8];

//objects allocated
int gc_total;

//objects marked
int gc_marked;

//toggling markbit
int gc_markbit;

//how much mem alloced
int gc_alloced;
int gc_maxalloced;

//queue of objects to mark
std::vector<gc_object*> gc_mark_queue;

//generated by translator
void gc_mark();
#define gc_mark_roots gc_mark

//void gc_mark_roots();

gc_object *gc_malloc( int size ){
	size=(size+7)&~7;
	
	gc_object *p;
	if( size<64 ){
		if( (p=gc_cache[size>>3]) ){
			gc_cache[size>>3]=p->succ;
		}else{
			p=(gc_object*)malloc( size );
		}
	}else{
		p=(gc_object*)malloc( size );
	}
	
	p->flags=size | (gc_markbit^1);
	p->succ=gc_objs;
	gc_objs=p;

	++gc_total;
	
	gc_alloced+=size;
	if( gc_alloced>gc_maxalloced ) gc_maxalloced=gc_alloced;
	
	return p;
}

void gc_free( gc_object *p ){
	int size=p->flags & ~7;
	if( size<64 ){
		p->succ=gc_cache[size>>3];
		gc_cache[size>>3]=p;
	}else{
		free( p );
	}
	--gc_total;
	gc_alloced-=size;
}

inline void gc_mark( gc_object *p ){
	if( !p || (p->flags & 1)==gc_markbit ) return;
	p->flags^=1;
	++gc_marked;
	p->mark();
}

inline void gc_mark_q( gc_object *p ){
	if( !p || (p->flags & 1)==gc_markbit ) return;
	p->flags^=1;
	++gc_marked;
	gc_mark_queue.push_back( p );
}

#if CFG_CPP_INCREMENTAL_GC

template<class T,class V> void gc_assign( T *&lhs,V *rhs ){
	//
	//Ok, the dynamic_cast should be 'free' if rhs is an object, not an interface, as it's a simple upcast.
	//
	//So far, this seems to be true of both msvc and llvm.
	//
	//This could be used with gc_mark and gc_mark_q, allowing gc_iptr to be nuked - yay! Later...
	//
	gc_mark_q( dynamic_cast<gc_object*>( rhs ) );
	lhs=rhs;
}

void gc_collect(){

#if DEBUG_GC
	int us=gcMicros();
#endif

	int swept=0;
	
	static int maxalloced;

	int c=0;
	
	if( gc_maxalloced>maxalloced ){
		maxalloced=gc_maxalloced;
		c=gc_total;
	}else{
		c=gc_total/10;
	}
	
	int term=gc_marked+c;
	
	while( gc_marked<term ){
	
		if( gc_mark_queue.empty() ){
		
			//sweep!
			
			gc_object **q=&gc_objs;
			
			swept=gc_total;
			
			while( gc_marked!=gc_total ){
				gc_object *p=*q;
				
				while( (p->flags & 1)==gc_markbit ){
					q=&p->succ;
					p=*q;
				}

				*q=p->succ;
				
				delete p;
			}
			
			swept-=gc_total;
			
			gc_markbit^=1;
			gc_marked=0;
			
			gc_mark_roots();
			
			break;
		}
		
		gc_object *p=gc_mark_queue.back();
		gc_mark_queue.pop_back();
		p->mark();
	}

#if DEBUG_GC
	us=gcMicros()-us;
	printf( "us=%i, swept=%i, objects=%i, memalloced=%i, maxalloced=%i\n",us,swept,gc_total,gc_alloced,gc_maxalloced );fflush( stdout );
#endif
}

#else

#define gc_assign( X,Y ) X=Y

void gc_collect(){

#if DEBUG_GC
	int us=gcMicros();
#endif
	
	//mark...

	gc_mark_roots();
	
	while( !gc_mark_queue.empty() ){
		gc_object *p=gc_mark_queue.back();
		gc_mark_queue.pop_back();
		p->mark();
	}
	
	//sweep...
	
	gc_object **q=&gc_objs;
	
	int swept=gc_total;

	while( gc_marked!=gc_total ){
		gc_object *p=*q;
		
		while( (p->flags & 1)==gc_markbit ){
			q=&p->succ;
			p=*q;
		}
		
		*q=p->succ;
		delete p;
	}
	
	swept-=gc_total;

	gc_markbit^=1;
	gc_marked=0;
	
#if DEBUG_GC
	us=gcMicros()-us;
	printf( "us=%i, swept=%i, objects=%i, memalloced=%i, maxalloced=%i\n",us,swept,gc_total,gc_alloced,gc_maxalloced );fflush( stdout );
#endif
}

#endif

// ***** Monkey Types *****

typedef wchar_t Char;
template<class T> class Array;
class String;
class Object;

// ***** Array *****

template<class T> T *t_memcpy( T *dst,const T *src,int n ){
	memcpy( dst,src,n*sizeof(T) );
	return dst+n;
}

template<class T> T *t_memset( T *dst,int val,int n ){
	memset( dst,val,n*sizeof(T) );
	return dst+n;
}

template<class T> int t_memcmp( const T *x,const T *y,int n ){
	return memcmp( x,y,n*sizeof(T) );
}

template<class T> int t_strlen( const T *p ){
	const T *q=p++;
	while( *q++ ){}
	return q-p;
}

template<class T> T *t_create( int n,T *p ){
	t_memset( p,0,n );
	return p+n;
}

template<class T> T *t_create( int n,T *p,const T *q ){
	t_memcpy( p,q,n );
	return p+n;
}

template<class T> void t_destroy( int n,T *p ){
}

//for int, float etc arrays...needs to go before Array<> decl to shut xcode 4.0.2 up.
template<class T> void gc_mark_array( int n,T *p ){
}

template<class T> class Array{
public:
	Array():rep( Rep::alloc(0) ){
	}

	//Use default...
//	Array( const Array<T> &t )...
	
	Array( int length ):rep( Rep::alloc( length ) ){
		t_create( rep->length,rep->data );
	}
	
	Array( const T *p,int length ):rep( Rep::alloc(length) ){
		t_create( rep->length,rep->data,p );
	}
	
	~Array(){
	}

	//Use default...
//	Array &operator=( const Array &t )...
	
	int Length()const{ 
		return rep->length; 
	}
	
	T &At( int index ){
		if( index<0 || index>=rep->length ) throw "Array index out of range";
		return rep->data[index]; 
	}
	
	const T &At( int index )const{
		if( index<0 || index>=rep->length ) throw "Array index out of range";
		return rep->data[index]; 
	}
	
	T &operator[]( int index ){ 
		return rep->data[index]; 
	}

	const T &operator[]( int index )const{
		return rep->data[index]; 
	}
	
	Array Slice( int from,int term )const{
		int len=rep->length;
		if( from<0 ){ 
			from+=len;
			if( from<0 ) from=0;
		}else if( from>len ){
			from=len;
		}
		if( term<0 ){
			term+=len;
		}else if( term>len ){
			term=len;
		}
		if( term<=from ) return Array();
		return Array( rep->data+from,term-from );
	}

	Array Slice( int from )const{
		return Slice( from,rep->length );
	}
	
	Array Resize( int newlen )const{
		if( newlen<=0 ) return Array();
		int n=rep->length;
		if( newlen<n ) n=newlen;
		Rep *p=Rep::alloc( newlen );
		T *q=p->data;
		q=t_create( n,q,rep->data );
		q=t_create( (newlen-n),q );
		return Array( p );
	}

private:
	struct Rep : public gc_object{
		int length;
		T data[0];
		
		Rep( int length ):length(length){
		}
		
		~Rep(){
			t_destroy( length,data );
		}
		
		void mark(){
			gc_mark_array( length,data );
		}
		
		static Rep *alloc( int length ){
			void *p=gc_malloc( sizeof(Rep)+length*sizeof(T) );
			return ::new(p) Rep( length );
		}
	};
	Rep *rep;

	template<class C> friend void gc_mark( Array<C> &t );
	template<class C> friend void gc_mark_q( Array<C> &t );

#if CFG_CPP_INCREMENTAL_GC

	template<class C> friend void gc_assign( Array<C> &lhs,Array<C> rhs );
	
#endif

	Array( Rep *rep ):rep(rep){
	}
};

template<class T> void gc_mark( Array<T> &t ){
	gc_mark( t.rep );
}

template<class T> void gc_mark_q( Array<T> &t ){
	gc_mark_q( t.rep );
}

//for object arrays....
template<class T> void gc_mark_array( int n,T **p ){
	for( int i=0;i<n;++i ) gc_mark( p[i] );
}

//for array arrays...
template<class T> void gc_mark_array( int n,Array<T> *p ){
	for( int i=0;i<n;++i ) gc_mark( p[i] );
}

#if CFG_CPP_INCREMENTAL_GC

template<class T> void gc_assign( Array<T> &lhs,Array<T> rhs ){
	gc_mark_q( rhs.rep );
	lhs=rhs;
}

#endif
		
// ***** String *****

class String{
public:
	String():rep( Rep::alloc(0) ){
	}
	
	String( const String &t ):rep( t.rep ){
		rep->retain();
	}

	String( int n ){
		char buf[256];
		sprintf( buf,"%i",n );
		rep=Rep::alloc( t_strlen(buf) );
		for( int i=0;i<rep->length;++i ) rep->data[i]=buf[i];
	}

	String( Float n ){
		char buf[256];
		
		//would rather use snprintf, but it's doing weird things in MingW.
		//
		sprintf( buf,"%.17lg",n );
		//
		char *p;
		for( p=buf;*p;++p ){
			if( *p=='.' || *p=='e' ) break;
		}
		if( !*p ){
			*p++='.';
			*p++='0';
			*p=0;
		}

		rep=Rep::alloc( t_strlen(buf) );
		for( int i=0;i<rep->length;++i ) rep->data[i]=buf[i];
	}

	String( Char ch,int length ):rep( Rep::alloc(length) ){
		for( int i=0;i<length;++i ) rep->data[i]=ch;
	}

	String( const Char *p ):rep( Rep::alloc(t_strlen(p)) ){
		t_memcpy( rep->data,p,rep->length );
	}

	String( const Char *p,int length ):rep( Rep::alloc(length) ){
		t_memcpy( rep->data,p,rep->length );
	}
	
#if __OBJC__	
	String( NSString *nsstr ):rep( Rep::alloc([nsstr length]) ){
		unichar *buf=(unichar*)malloc( rep->length * sizeof(unichar) );
		[nsstr getCharacters:buf range:NSMakeRange(0,rep->length)];
		for( int i=0;i<rep->length;++i ) rep->data[i]=buf[i];
		free( buf );
	}
#endif

	~String(){
		rep->release();
	}
	
	template<class C> String( const C *p ):rep( Rep::alloc(t_strlen(p)) ){
		for( int i=0;i<rep->length;++i ) rep->data[i]=p[i];
	}
	
	template<class C> String( const C *p,int length ):rep( Rep::alloc(length) ){
		for( int i=0;i<rep->length;++i ) rep->data[i]=p[i];
	}
	
	int Length()const{
		return rep->length;
	}
	
	const Char *Data()const{
		return rep->data;
	}
	
	Char operator[]( int index )const{
		return rep->data[index];
	}
	
	String &operator=( const String &t ){
		t.rep->retain();
		rep->release();
		rep=t.rep;
		return *this;
	}
	
	String &operator+=( const String &t ){
		return operator=( *this+t );
	}
	
	int Compare( const String &t )const{
		int n=rep->length<t.rep->length ? rep->length : t.rep->length;
		for( int i=0;i<n;++i ){
			if( int q=(int)(rep->data[i])-(int)(t.rep->data[i]) ) return q;
		}
		return rep->length-t.rep->length;
	}
	
	bool operator==( const String &t )const{
		return rep->length==t.rep->length && t_memcmp( rep->data,t.rep->data,rep->length )==0;
	}
	
	bool operator!=( const String &t )const{
		return rep->length!=t.rep->length || t_memcmp( rep->data,t.rep->data,rep->length )!=0;
	}
	
	bool operator<( const String &t )const{
		return Compare( t )<0;
	}
	
	bool operator<=( const String &t )const{
		return Compare( t )<=0;
	}
	
	bool operator>( const String &t )const{
		return Compare( t )>0;
	}
	
	bool operator>=( const String &t )const{
		return Compare( t )>=0;
	}
	
	String operator+( const String &t )const{
		if( !rep->length ) return t;
		if( !t.rep->length ) return *this;
		Rep *p=Rep::alloc( rep->length+t.rep->length );
		Char *q=p->data;
		q=t_memcpy( q,rep->data,rep->length );
		q=t_memcpy( q,t.rep->data,t.rep->length );
		return String( p );
	}
	
	int Find( String find,int start=0 )const{
		if( start<0 ) start=0;
		while( start+find.rep->length<=rep->length ){
			if( !t_memcmp( rep->data+start,find.rep->data,find.rep->length ) ) return start;
			++start;
		}
		return -1;
	}
	
	int FindLast( String find )const{
		int start=rep->length-find.rep->length;
		while( start>=0 ){
			if( !t_memcmp( rep->data+start,find.rep->data,find.rep->length ) ) return start;
			--start;
		}
		return -1;
	}
	
	int FindLast( String find,int start )const{
		if( start>rep->length-find.rep->length ) start=rep->length-find.rep->length;
		while( start>=0 ){
			if( !t_memcmp( rep->data+start,find.rep->data,find.rep->length ) ) return start;
			--start;
		}
		return -1;
	}
	
	String Trim()const{
		int i=0,i2=rep->length;
		while( i<i2 && rep->data[i]<=32 ) ++i;
		while( i2>i && rep->data[i2-1]<=32 ) --i2;
		if( i==0 && i2==rep->length ) return *this;
		return String( rep->data+i,i2-i );
	}

	Array<String> Split( String sep )const{
	
		if( !sep.rep->length ){
			Array<String> bits( rep->length );
			for( int i=0;i<rep->length;++i ){
				bits[i]=String( (Char)(*this)[i],1 );
			}
			return bits;
		}
		
		int i=0,i2,n=1;
		while( (i2=Find( sep,i ))!=-1 ){
			++n;
			i=i2+sep.rep->length;
		}
		Array<String> bits( n );
		if( n==1 ){
			bits[0]=*this;
			return bits;
		}
		i=0;n=0;
		while( (i2=Find( sep,i ))!=-1 ){
			bits[n++]=Slice( i,i2 );
			i=i2+sep.rep->length;
		}
		bits[n]=Slice( i );
		return bits;
	}

	String Join( Array<String> bits )const{
		if( bits.Length()==0 ) return String();
		if( bits.Length()==1 ) return bits[0];
		int newlen=rep->length * (bits.Length()-1);
		for( int i=0;i<bits.Length();++i ){
			newlen+=bits[i].rep->length;
		}
		Rep *p=Rep::alloc( newlen );
		Char *q=p->data;
		q=t_memcpy( q,bits[0].rep->data,bits[0].rep->length );
		for( int i=1;i<bits.Length();++i ){
			q=t_memcpy( q,rep->data,rep->length );
			q=t_memcpy( q,bits[i].rep->data,bits[i].rep->length );
		}
		return String( p );
	}

	String Replace( String find,String repl )const{
		int i=0,i2,newlen=0;
		while( (i2=Find( find,i ))!=-1 ){
			newlen+=(i2-i)+repl.rep->length;
			i=i2+find.rep->length;
		}
		if( !i ) return *this;
		newlen+=rep->length-i;
		Rep *p=Rep::alloc( newlen );
		Char *q=p->data;
		i=0;
		while( (i2=Find( find,i ))!=-1 ){
			q=t_memcpy( q,rep->data+i,i2-i );
			q=t_memcpy( q,repl.rep->data,repl.rep->length );
			i=i2+find.rep->length;
		}
		q=t_memcpy( q,rep->data+i,rep->length-i );
		return String( p );
	}

	String ToLower()const{
		for( int i=0;i<rep->length;++i ){
			Char t=tolower( rep->data[i] );
			if( t==rep->data[i] ) continue;
			Rep *p=Rep::alloc( rep->length );
			Char *q=p->data;
			t_memcpy( q,rep->data,i );
			for( q[i++]=t;i<rep->length;++i ){
				q[i]=tolower( rep->data[i] );
			}
			return String( p );
		}
		return *this;
	}

	String ToUpper()const{
		for( int i=0;i<rep->length;++i ){
			Char t=toupper( rep->data[i] );
			if( t==rep->data[i] ) continue;
			Rep *p=Rep::alloc( rep->length );
			Char *q=p->data;
			t_memcpy( q,rep->data,i );
			for( q[i++]=t;i<rep->length;++i ){
				q[i]=toupper( rep->data[i] );
			}
			return String( p );
		}
		return *this;
	}
	
	bool Contains( String sub )const{
		return Find( sub )!=-1;
	}

	bool StartsWith( String sub )const{
		return sub.rep->length<=rep->length && !t_memcmp( rep->data,sub.rep->data,sub.rep->length );
	}

	bool EndsWith( String sub )const{
		return sub.rep->length<=rep->length && !t_memcmp( rep->data+rep->length-sub.rep->length,sub.rep->data,sub.rep->length );
	}
	
	String Slice( int from,int term )const{
		int len=rep->length;
		if( from<0 ){
			from+=len;
			if( from<0 ) from=0;
		}else if( from>len ){
			from=len;
		}
		if( term<0 ){
			term+=len;
		}else if( term>len ){
			term=len;
		}
		if( term<from ) return String();
		if( from==0 && term==len ) return *this;
		return String( rep->data+from,term-from );
	}

	String Slice( int from )const{
		return Slice( from,rep->length );
	}
	
	int ToInt()const{
		return atoi( ToCString<char>() );
	}
	
	Float ToFloat()const{
		return atof( ToCString<char>() );
	}
	
	template<class C> C *ToCString()const{

		C *p=&Array<C>( rep->length+1 )[0];
		
		for( int i=0;i<rep->length;++i ) p[i]=rep->data[i];
		p[rep->length]=0;
		return p;
	}

#if __OBJC__	
	NSString *ToNSString()const{
		return [NSString stringWithCharacters:ToCString<unichar>() length:rep->length];
	}
#endif

	bool Save( FILE *fp ){
		std::vector<unsigned char> buf;
		Save( buf );
		return fwrite( &buf[0],1,buf.size(),fp )==buf.size();
	}
	
	void Save( std::vector<unsigned char> &buf ){
	
		bool uni=false;
		
		for( int i=0;i<rep->length;++i ){
			if( rep->data[i]>=0xfe ){
				uni=true;
				break;
			}
		}
		
		if( uni ){
			Char c;
			unsigned char *p=(unsigned char*)&c;
			c=0xfeff;
			buf.push_back( p[0] );
			buf.push_back( p[1] );
			for( int i=0;i<rep->length;++i ){
				c=rep->data[i];
				buf.push_back( p[0] );
				buf.push_back( p[1] );
			}
		}else{
			for( int i=0;i<rep->length;++i ){
				buf.push_back( rep->data[i] );
			}
		}
	}
	
	static String FromChars( Array<int> chars ){
		int n=chars.Length();
		Rep *p=Rep::alloc( n );
		for( int i=0;i<n;++i ){
			p->data[i]=chars[i];
		}
		return String( p );
	}

	static String Load( FILE *fp ){
		unsigned char tmp[4096];
		std::vector<unsigned char> buf;
		for(;;){
			int n=fread( tmp,1,4096,fp );
			if( n>0 ) buf.insert( buf.end(),tmp,tmp+n );
			if( n!=4096 ) break;
		}
		return String::Load( &buf[0],buf.size() );
	}
	
	static String Load( unsigned char *p,int n ){
	
		if( n<3 ) return String( p,n );
		
		unsigned char *term=p+n;
		std::vector<Char> chars;

		int c=*p++;
		int d=*p++;
		
		if( c==0xfe && d==0xff ){
			while( p<term-1 ){
				int c=*p++;
				chars.push_back( (c<<8)|*p++ );
			}
		}else if( c==0xff && d==0xfe ){
			while( p<term-1 ){
				int c=*p++;
				chars.push_back( (*p++<<8)|c );
			}
		}else{
			int e=*p++;
			if( c!=0xef || d!=0xbb || e!=0xbf ) return String( p-3,n );
			while( p<term ){
				int c=*p++;
				if( c>=128 && p<term ){
					int d=*p++;
					if( c>=224 && p<term ){
						int e=*p++;
						if( c>=240 ) break;	//Illegal UTF8!
						c=(c-224)*4096+(d-128)*64+(e-128);
					}else{
						c=(c-192)*64+(d-128);
					}
				}
				chars.push_back( c );
			}
		}
		return String( &chars[0],chars.size() );
	}
	
private:
	struct Rep{
		int refs;
		int length;
		Char data[0];
		
		Rep( int length ):refs(1),length(length){
		}
		
		void retain(){
			++refs;
		}
		
		void release(){
			if( --refs || !length ) return;
			free( this );
		}

		static Rep *alloc( int length ){
			if( !length ){
				static Rep null(0);
				return &null;
			}
			void *p=malloc( sizeof(Rep)+length*sizeof(Char) );
			return new(p) Rep( length );
		}
	};
	Rep *rep;
	
	String( Rep *rep ):rep(rep){
	}
};

String *t_create( int n,String *p ){
	for( int i=0;i<n;++i ) new( &p[i] ) String();
	return p+n;
}

String *t_create( int n,String *p,const String *q ){
	for( int i=0;i<n;++i ) new( &p[i] ) String( q[i] );
	return p+n;
}

void t_destroy( int n,String *p ){
	for( int i=0;i<n;++i ) p[i].~String();
}

String T( const char *p ){
	return String( p );
}

String T( const wchar_t *p ){
	return String( p );
}

// ***** Object *****

class Object : public gc_object{
public:
	virtual bool Equals( Object *obj ){
		return this==obj;
	}
	
	virtual int Compare( Object *obj ){
		return (char*)this-(char*)obj;
	}
};

//Some ugly hacks for interfaces in an attempt to keep plain objects speedy.
//
//This mess is mainly to prevent classes from having to virtually inherit 'Object', which incurs quite a
//bit of overhead when upcasting to Object.
//
struct gc_interface{
	virtual ~gc_interface(){}
	
//	gc_object *to_object(){ return dynamic_cast<gc_object*>(this) );
};

template<class T>
struct gc_iptr{
	T *p;
	gc_iptr(){}
	gc_iptr( T *p ):p(p){} 
};

template<class T> void gc_mark( gc_iptr<T> i ){
	gc_mark( dynamic_cast<gc_object*>(i.p) );
}

template<class T> void gc_mark_q( gc_iptr<T> i ){
	gc_mark_q( dynamic_cast<gc_object*>(i.p) );
}

//mark array of iptrs
template<class T> void gc_mark_array( int n,gc_iptr<T> *p ){
	for( int i=0;i<n;++i ) gc_mark( dynamic_cast<gc_object*>( p[i].p ) );
}

#if CFG_CPP_INCREMENTAL_GC

//template<class T,class V> void gc_assign( gc_iptr<T> *lhs,V *rhs ){
//	gc_mark_q( dynamic_cast<gc_object*>( rhs ) );
//	lhs->p=rhs;
//}

#endif

//**** main ****

int argc;
const char **argv;
const char *errInfo="";
std::vector<const char*> errStack;

Float D2R=0.017453292519943295f;
Float R2D=57.29577951308232f;

void pushErr(){
	errStack.push_back( errInfo );
}

void popErr(){
	errInfo=errStack.back();
	errStack.pop_back();
}

String StackTrace(){
	String str;
	pushErr();
	for( int i=errStack.size()-1;i>=0;--i ){
		str+=String( errStack[i] )+"\n";
	}
	popErr();
	return str;
}

int Print( String t ){
	puts( t.ToCString<char>() );
	fflush( stdout );
	return 0;
}

int Error( String err ){
	throw err.ToCString<char>();
	return 0;
}

int Compare( int x,int y ){
	return x-y;
}

int Compare( Float x,Float y ){
	return x<y ? -1 : x>y;
}

int Compare( String x,String y ){
	return x.Compare( y );
}

int bbInit();
int bbMain();

#if _MSC_VER

//Ok, this is butt ugly stuff, but MSVC's SEH seems to be the only
//way you can catch int divide by zero...let's use it for null objects too...
//
const char *FilterException( int type ){
	switch( type ){
	case STATUS_ACCESS_VIOLATION:return "Memory access violation";
	case STATUS_INTEGER_DIVIDE_BY_ZERO:return "Integer divide by zero";
	}
	return 0;
}

int seh_call( int(*f)() ){
	const char *p;
	__try{
		return f();
	}__except( (p=FilterException(GetExceptionCode()))!=0 ){
		puts( p );
		throw p;
	}
}

#else

int seh_call( int(*f)() ){
	return f();
}

void sighandler( int sig  ){
	switch( sig ){
	case SIGILL:throw "Illegal instruction";
	case SIGFPE:throw "Floating point exception";
#if !_WIN32
	case SIGBUS:throw "Bus error";
#endif
	case SIGSEGV:throw "Segmentation violation";
	}
	throw "Unknown exception";
}

#endif

//entry point call by target main()...
//
int bb_std_main( int argc,const char **argv ){
	
	::argc=argc;
	::argv=argv;
	
#if !_MSC_VER
	signal( SIGILL,sighandler );
	signal( SIGFPE,sighandler );
#if !_WIN32
	signal( SIGBUS,sighandler );
#endif
	signal( SIGSEGV,sighandler );
#endif

	P_START
	
	seh_call( bbInit );
	
#if CFG_CPP_INCREMENTAL_GC
	gc_mark_roots();
#endif
	
	seh_call( bbMain );
	
	P_STOP
	
	return 0;
}

// Stdcpp trans.system runtime.
//
// Placed into the public domain 24/02/2011.
// No warranty implied; use as your own risk.

#if _WIN32

/*
#include <windows.h>
#include <direct.h>
#include <sys/stat.h>
*/

#ifndef PATH_MAX
#define PATH_MAX MAX_PATH
#endif

typedef wchar_t OS_CHAR;
typedef struct _stat stat_t;

#define mkdir( X,Y ) _wmkdir( X )
#define rmdir _wrmdir
#define remove _wremove
#define rename _wrename
#define stat _wstat
#define _fopen _wfopen
#define putenv _wputenv
#define getenv _wgetenv
#define system _wsystem
#define chdir _wchdir
#define getcwd _wgetcwd
#define realpath(X,Y) _wfullpath( Y,X,PATH_MAX )	//Note: first args SWAPPED to be posix-like!
#define opendir _wopendir
#define readdir _wreaddir
#define closedir _wclosedir
#define DIR _WDIR
#define dirent _wdirent

#elif __APPLE__

/*
#include <mach-o/dyld.h>
#include <sys/stat.h>
#include <dirent.h>
#include <copyfile.h>
*/

typedef char OS_CHAR;
typedef struct stat stat_t;

#define _fopen fopen

#elif __linux

/*
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
*/

typedef char OS_CHAR;
typedef struct stat stat_t;

#define _fopen fopen

#endif

static String _appPath;
static Array<String> _appArgs;

static char *C_STR( const String &t ){
	return t.ToCString<char>();
}

static OS_CHAR *OS_STR( const String &t ){
	return t.ToCString<OS_CHAR>();
}

String HostOS(){
#if _WIN32
	return "winnt";
#elif __APPLE__
	return "macos";
#elif __linux
	return "linux";
#else
	return "";
#endif
}

String RealPath( String path ){
	std::vector<OS_CHAR> buf( PATH_MAX+1 );
	realpath( OS_STR( path ),&buf[0] );
	buf[buf.size()-1]=0;
	for( int i=0;i<PATH_MAX && buf[i];++i ){
		if( buf[i]=='\\' ) buf[i]='/';
		
	}
	return String( &buf[0] );
}

String AppPath(){

	if( _appPath.Length() ) return _appPath;
	
#if _WIN32

	OS_CHAR buf[PATH_MAX+1];
	GetModuleFileNameW( GetModuleHandleW(0),buf,PATH_MAX );
	buf[PATH_MAX]=0;
	_appPath=String( buf );
	
#elif __APPLE__

	char buf[PATH_MAX];
	uint32_t size=sizeof( buf );
	_NSGetExecutablePath( buf,&size );
	buf[PATH_MAX-1]=0;
	_appPath=String( buf );
	
#elif __linux

	char lnk[PATH_MAX],buf[PATH_MAX];
	pid_t pid=getpid();
	sprintf( lnk,"/proc/%i/exe",pid );
	int i=readlink( lnk,buf,PATH_MAX );
	if( i>0 && i<PATH_MAX ){
		buf[i]=0;
		_appPath=String( buf );
	}

#endif

	_appPath=RealPath( _appPath );
	return _appPath;
}

Array<String> AppArgs(){
	if( _appArgs.Length() ) return _appArgs;
	_appArgs=Array<String>( argc );
	for( int i=0;i<argc;++i ){
		_appArgs[i]=String( argv[i] );
	}
	return _appArgs;
}
	
int FileType( String path ){
	stat_t st;
	if( stat( OS_STR(path),&st ) ) return 0;
	switch( st.st_mode & S_IFMT ){
	case S_IFREG : return 1;
	case S_IFDIR : return 2;
	}
	return 0;
}

int FileSize( String path ){
	stat_t st;
	if( stat( OS_STR(path),&st ) ) return -1;
	return st.st_size;
}

int FileTime( String path ){
	stat_t st;
	if( stat( OS_STR(path),&st ) ) return -1;
	return st.st_mtime;
}

String LoadString( String path ){
	if( FILE *fp=_fopen( OS_STR(path),OS_STR("rb") ) ){
		String str=String::Load( fp );
		fclose( fp );
		return str;
	}
	printf( "FOPEN 'rb' for LoadString '%s' failed\n",C_STR( path ) );fflush( stdout );
	return "";
}
	
int SaveString( String str,String path ){
	if( FILE *fp=_fopen( OS_STR(path),OS_STR("wb") ) ){
		bool ok=str.Save( fp );
		fclose( fp );
		return ok ? 0 : -2;
	}else{
		printf( "FOPEN 'wb' for SaveString '%s' failed\n",C_STR( path ) );
		fflush( stdout );
	}
	return -1;
}

Array<String> LoadDir( String path ){
	std::vector<String> files;
	
#if _WIN32

	WIN32_FIND_DATAW filedata;
	HANDLE handle=FindFirstFileW( OS_STR(path+"/*"),&filedata );
	if( handle!=INVALID_HANDLE_VALUE ){
		do{
			String f=filedata.cFileName;
			if( f=="." || f==".." ) continue;
			files.push_back( f );
		}while( FindNextFileW( handle,&filedata ) );
		FindClose( handle );
	}else{
		printf( "FindFirstFileW for LoadDir(%s) failed\n",C_STR(path) );
		fflush( stdout );
	}
	
#else

	if( DIR *dir=opendir( OS_STR(path) ) ){
		while( dirent *ent=readdir( dir ) ){
			String f=ent->d_name;
			if( f=="." || f==".." ) continue;
			files.push_back( f );
		}
		closedir( dir );
	}else{
		printf( "opendir for LoadDir(%s) failed\n",C_STR(path) );
		fflush( stdout );
	}

#endif

	return Array<String>( &files[0],files.size() );
}
	
int CopyFile( String srcpath,String dstpath ){

#if _WIN32

	if( CopyFileW( OS_STR(srcpath),OS_STR(dstpath),FALSE ) ) return 1;
	return 0;
	
#elif __APPLE__

	// Would like to use COPY_ALL here, but it breaks trans on MacOS - produces weird 'pch out of date' error with copied projects.
	//
	// Ranlib strikes back!
	//
	if( copyfile( OS_STR(srcpath),OS_STR(dstpath),0,COPYFILE_DATA )>=0 ) return 1;
	return 0;
	
#else

	int err=-1;
	if( FILE *srcp=_fopen( OS_STR( srcpath ),OS_STR( T("rb") ) ) ){
		err=-2;
		if( FILE *dstp=_fopen( OS_STR( dstpath ),OS_STR( T("wb") ) ) ){
			err=0;
			char buf[1024];
			while( int n=fread( buf,1,1024,srcp ) ){
				if( fwrite( buf,1,n,dstp )!=n ){
					err=-3;
					break;
				}
			}
			fclose( dstp );
		}else{
			printf( "FOPEN 'wb' for CopyFile(%s,%s) failed\n",C_STR(srcpath),C_STR(dstpath) );
			fflush( stdout );
		}
		fclose( srcp );
	}else{
		printf( "FOPEN 'rb' for CopyFile(%s,%s) failed\n",C_STR(srcpath),C_STR(dstpath) );
		fflush( stdout );
	}
	return err==0;
	
#endif
}

int ChangeDir( String path ){
	return chdir( OS_STR(path) );
}

String CurrentDir(){
	std::vector<OS_CHAR> buf( PATH_MAX+1 );
	getcwd( &buf[0],buf.size() );
	buf[buf.size()-1]=0;
	return String( &buf[0] );
}

int CreateDir( String path ){
	mkdir( OS_STR( path ),0777 );
	return FileType(path)==2;
}

int DeleteDir( String path ){
	rmdir( OS_STR(path) );
	return FileType(path)==0;
}

int DeleteFile( String path ){
	remove( OS_STR(path) );
	return FileType(path)==0;
}

int SetEnv( String name,String value ){
	return putenv( OS_STR( String(name)+T("=")+String(value) ) );
}

String GetEnv( String name ){
	if( OS_CHAR *p=getenv( OS_STR(name) ) ) return String( p );
	return T("");
}

int Execute( String cmd ){

#if _WIN32

	cmd=T("cmd /S /C \"")+cmd+T("\"");

	PROCESS_INFORMATION pi={0};
	STARTUPINFOW si={sizeof(si)};

	if( !CreateProcessW( 0,(WCHAR*)OS_STR(cmd),0,0,1,0,0,0,&si,&pi ) ) return -1;

	WaitForSingleObject( pi.hProcess,INFINITE );

	int res=GetExitCodeProcess( pi.hProcess,(DWORD*)&res ) ? res : -1;

	CloseHandle( pi.hProcess );
	CloseHandle( pi.hThread );

	return res;

#else

	return system( OS_STR(cmd) );

#endif
}

int ExitApp( int retcode ){
	exit( retcode );
	return 0;
}
class bb_boxes_BoolObject;
class bb_boxes_IntObject;
class bb_boxes_FloatObject;
class bb_boxes_StringObject;
class bb_reflection_ClassInfo;
class bb_reflection_R2;
class bb_reflection_UnknownClass;
class bb_reflection_R8;
class bb_reflection_R18;
class bb_reflection_R28;
class bb_reflection__GetClass;
class bb_reflection___GetClass;
class bb_compiler_Compiler;
class bb_compiler_CompileError;
class bb_list_List;
class bb_list_Node;
class bb_list_HeadNode;
class bb_lexer_Lexer;
class bb_byref_BoolByRef;
class bb_token_Token;
class bb_list_List2;
class bb_list_Node2;
class bb_list_HeadNode2;
class bb_token_eToken;
class bb_list_Enumerator;
class bb_list_Enumerator2;
class bb_reflection_FieldInfo;
class bb_reflection_R3;
class bb_reflection_MethodInfo;
class bb_reflection_R5;
class bb_reflection_R6;
class bb_reflection_FunctionInfo;
class bb_reflection_R4;
class bb_reflection_R7;
class bb_reflection_R9;
class bb_reflection_R12;
class bb_reflection_R13;
class bb_reflection_R14;
class bb_reflection_R15;
class bb_reflection_R16;
class bb_reflection_R10;
class bb_reflection_R11;
class bb_reflection_R17;
class bb_reflection_R19;
class bb_reflection_R22;
class bb_reflection_R23;
class bb_reflection_R24;
class bb_reflection_R25;
class bb_reflection_R26;
class bb_reflection_R20;
class bb_reflection_R21;
class bb_reflection_R27;
class bb_reflection_R29;
class bb_reflection_R33;
class bb_reflection_R34;
class bb_reflection_R35;
class bb_reflection_R30;
class bb_reflection_R31;
class bb_reflection_R32;
class bb_reflection_R36;
class bb_boxes_BoolObject : public Object{
	public:
	bool f_value;
	bb_boxes_BoolObject();
	bb_boxes_BoolObject* g_new(bool);
	virtual bool m_ToBool();
	virtual bool m_Equals(bb_boxes_BoolObject*);
	bb_boxes_BoolObject* g_new2();
	void mark();
};
class bb_boxes_IntObject : public Object{
	public:
	int f_value;
	bb_boxes_IntObject();
	bb_boxes_IntObject* g_new(int);
	bb_boxes_IntObject* g_new2(Float);
	virtual int m_ToInt();
	virtual Float m_ToFloat();
	virtual String m_ToString();
	virtual bool m_Equals2(bb_boxes_IntObject*);
	virtual int m_Compare(bb_boxes_IntObject*);
	bb_boxes_IntObject* g_new3();
	void mark();
};
class bb_boxes_FloatObject : public Object{
	public:
	Float f_value;
	bb_boxes_FloatObject();
	bb_boxes_FloatObject* g_new(int);
	bb_boxes_FloatObject* g_new2(Float);
	virtual int m_ToInt();
	virtual Float m_ToFloat();
	virtual String m_ToString();
	virtual bool m_Equals3(bb_boxes_FloatObject*);
	virtual int m_Compare2(bb_boxes_FloatObject*);
	bb_boxes_FloatObject* g_new3();
	void mark();
};
class bb_boxes_StringObject : public Object{
	public:
	String f_value;
	bb_boxes_StringObject();
	bb_boxes_StringObject* g_new(int);
	bb_boxes_StringObject* g_new2(Float);
	bb_boxes_StringObject* g_new3(String);
	virtual String m_ToString();
	virtual bool m_Equals4(bb_boxes_StringObject*);
	virtual int m_Compare3(bb_boxes_StringObject*);
	bb_boxes_StringObject* g_new4();
	void mark();
};
class bb_reflection_ClassInfo : public Object{
	public:
	String f__name;
	int f__attrs;
	bb_reflection_ClassInfo* f__sclass;
	Array<bb_reflection_ClassInfo* > f__ifaces;
	Array<bb_reflection_FieldInfo* > f__fields;
	Array<bb_reflection_MethodInfo* > f__methods;
	Array<bb_reflection_FunctionInfo* > f__ctors;
	bb_reflection_ClassInfo();
	bb_reflection_ClassInfo* g_new(String,int,bb_reflection_ClassInfo*,Array<bb_reflection_ClassInfo* >);
	bb_reflection_ClassInfo* g_new2();
	virtual int m_Init();
	void mark();
};
extern Array<bb_reflection_ClassInfo* > bb_reflection__classes;
class bb_reflection_R2 : public bb_reflection_ClassInfo{
	public:
	bb_reflection_R2();
	bb_reflection_R2* g_new();
	virtual int m_Init();
	void mark();
};
class bb_reflection_UnknownClass : public bb_reflection_ClassInfo{
	public:
	bb_reflection_UnknownClass();
	bb_reflection_UnknownClass* g_new();
	void mark();
};
extern bb_reflection_ClassInfo* bb_reflection__unknownClass;
extern bb_reflection_ClassInfo* bb_reflection__boolClass;
class bb_reflection_R8 : public bb_reflection_ClassInfo{
	public:
	bb_reflection_R8();
	bb_reflection_R8* g_new();
	virtual int m_Init();
	void mark();
};
extern bb_reflection_ClassInfo* bb_reflection__intClass;
class bb_reflection_R18 : public bb_reflection_ClassInfo{
	public:
	bb_reflection_R18();
	bb_reflection_R18* g_new();
	virtual int m_Init();
	void mark();
};
extern bb_reflection_ClassInfo* bb_reflection__floatClass;
class bb_reflection_R28 : public bb_reflection_ClassInfo{
	public:
	bb_reflection_R28();
	bb_reflection_R28* g_new();
	virtual int m_Init();
	void mark();
};
extern bb_reflection_ClassInfo* bb_reflection__stringClass;
class bb_reflection__GetClass : public Object{
	public:
	bb_reflection__GetClass();
	bb_reflection__GetClass* g_new();
	void mark();
};
class bb_reflection___GetClass : public bb_reflection__GetClass{
	public:
	bb_reflection___GetClass();
	bb_reflection___GetClass* g_new();
	void mark();
};
extern bb_reflection__GetClass* bb_reflection__getClass;
int bb_reflection___init();
extern int bb_reflection__init;
String bb_Harpl_AppString();
int bb_Harpl_ShowCommandLineArgs();
void bb_Harpl_AbortExecution(String,int);
class bb_compiler_Compiler : public Object{
	public:
	bb_list_List* f_compileErrors;
	bb_lexer_Lexer* f_lexer;
	bb_compiler_Compiler();
	bb_compiler_Compiler* g_new();
	virtual int m_AddError(String,String,int,int);
	virtual bool m_CompileFile(String);
	void mark();
};
class bb_compiler_CompileError : public Object{
	public:
	String f_description;
	String f_file;
	int f_posX;
	int f_posY;
	bb_compiler_CompileError();
	bb_compiler_CompileError* g_new();
	void mark();
};
class bb_list_List : public Object{
	public:
	bb_list_Node* f__head;
	bb_list_List();
	bb_list_List* g_new();
	virtual bb_list_Node* m_AddLast(bb_compiler_CompileError*);
	bb_list_List* g_new2(Array<bb_compiler_CompileError* >);
	virtual bool m_IsEmpty();
	virtual bb_list_Enumerator2* m_ObjectEnumerator();
	void mark();
};
class bb_list_Node : public Object{
	public:
	bb_list_Node* f__succ;
	bb_list_Node* f__pred;
	bb_compiler_CompileError* f__data;
	bb_list_Node();
	bb_list_Node* g_new(bb_list_Node*,bb_list_Node*,bb_compiler_CompileError*);
	bb_list_Node* g_new2();
	void mark();
};
class bb_list_HeadNode : public bb_list_Node{
	public:
	bb_list_HeadNode();
	bb_list_HeadNode* g_new();
	void mark();
};
class bb_lexer_Lexer : public Object{
	public:
	bb_list_List2* f_tokens;
	bb_lexer_Lexer();
	bb_lexer_Lexer* g_new();
	virtual int m_Tokenize(String,bb_compiler_Compiler*,String);
	void mark();
};
class bb_byref_BoolByRef : public Object{
	public:
	bool f_value;
	bb_byref_BoolByRef();
	bb_byref_BoolByRef* g_new();
	void mark();
};
class bb_token_Token : public Object{
	public:
	String f_sourceFile;
	int f__kind;
	int f_docX;
	int f_docY;
	String f_text;
	bb_token_Token();
	virtual int m_Kind();
	virtual void m_Kind2(int);
	bb_token_Token* g_new(String,int,int,String,int);
	bb_token_Token* g_new2();
	void mark();
};
class bb_list_List2 : public Object{
	public:
	bb_list_Node2* f__head;
	bb_list_List2();
	bb_list_List2* g_new();
	virtual bb_list_Node2* m_AddLast2(bb_token_Token*);
	bb_list_List2* g_new2(Array<bb_token_Token* >);
	virtual int m_Clear();
	virtual bb_list_Node2* m_FirstNode();
	virtual bb_list_Enumerator* m_ObjectEnumerator();
	void mark();
};
class bb_list_Node2 : public Object{
	public:
	bb_list_Node2* f__succ;
	bb_list_Node2* f__pred;
	bb_token_Token* f__data;
	bb_list_Node2();
	bb_list_Node2* g_new(bb_list_Node2*,bb_list_Node2*,bb_token_Token*);
	bb_list_Node2* g_new2();
	virtual bb_list_Node2* m_GetNode();
	virtual bb_list_Node2* m_NextNode();
	virtual bb_token_Token* m_Value();
	virtual int m_Remove();
	virtual bb_list_Node2* m_PrevNode();
	void mark();
};
class bb_list_HeadNode2 : public bb_list_Node2{
	public:
	bb_list_HeadNode2();
	bb_list_HeadNode2* g_new();
	virtual bb_list_Node2* m_GetNode();
	void mark();
};
bool bb_lexer_IsAValidIdentifierChar(int);
class bb_token_eToken : public Object{
	public:
	bb_token_eToken();
	void mark();
};
int bb_stringutils_HexToInteger(String,bb_byref_BoolByRef*);
String bb_lexer_ScapeChars(String);
String bb_retro_Mid(String,int,int);
String bb_retro_Mid2(String,int);
class bb_list_Enumerator : public Object{
	public:
	bb_list_List2* f__list;
	bb_list_Node2* f__curr;
	bb_list_Enumerator();
	bb_list_Enumerator* g_new(bb_list_List2*);
	bb_list_Enumerator* g_new2();
	virtual bool m_HasNext();
	virtual bb_token_Token* m_NextObject();
	void mark();
};
class bb_list_Enumerator2 : public Object{
	public:
	bb_list_List* f__list;
	bb_list_Node* f__curr;
	bb_list_Enumerator2();
	bb_list_Enumerator2* g_new(bb_list_List*);
	bb_list_Enumerator2* g_new2();
	virtual bool m_HasNext();
	virtual bb_compiler_CompileError* m_NextObject();
	void mark();
};
int bbMain();
class bb_reflection_FieldInfo : public Object{
	public:
	String f__name;
	int f__attrs;
	bb_reflection_ClassInfo* f__type;
	bb_reflection_FieldInfo();
	bb_reflection_FieldInfo* g_new(String,int,bb_reflection_ClassInfo*);
	bb_reflection_FieldInfo* g_new2();
	void mark();
};
class bb_reflection_R3 : public bb_reflection_FieldInfo{
	public:
	bb_reflection_R3();
	bb_reflection_R3* g_new();
	void mark();
};
class bb_reflection_MethodInfo : public Object{
	public:
	String f__name;
	int f__attrs;
	bb_reflection_ClassInfo* f__retType;
	Array<bb_reflection_ClassInfo* > f__argTypes;
	bb_reflection_MethodInfo();
	bb_reflection_MethodInfo* g_new(String,int,bb_reflection_ClassInfo*,Array<bb_reflection_ClassInfo* >);
	bb_reflection_MethodInfo* g_new2();
	void mark();
};
class bb_reflection_R5 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R5();
	bb_reflection_R5* g_new();
	void mark();
};
class bb_reflection_R6 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R6();
	bb_reflection_R6* g_new();
	void mark();
};
class bb_reflection_FunctionInfo : public Object{
	public:
	String f__name;
	int f__attrs;
	bb_reflection_ClassInfo* f__retType;
	Array<bb_reflection_ClassInfo* > f__argTypes;
	bb_reflection_FunctionInfo();
	bb_reflection_FunctionInfo* g_new(String,int,bb_reflection_ClassInfo*,Array<bb_reflection_ClassInfo* >);
	bb_reflection_FunctionInfo* g_new2();
	void mark();
};
class bb_reflection_R4 : public bb_reflection_FunctionInfo{
	public:
	bb_reflection_R4();
	bb_reflection_R4* g_new();
	void mark();
};
class bb_reflection_R7 : public bb_reflection_FunctionInfo{
	public:
	bb_reflection_R7();
	bb_reflection_R7* g_new();
	void mark();
};
class bb_reflection_R9 : public bb_reflection_FieldInfo{
	public:
	bb_reflection_R9();
	bb_reflection_R9* g_new();
	void mark();
};
class bb_reflection_R12 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R12();
	bb_reflection_R12* g_new();
	void mark();
};
class bb_reflection_R13 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R13();
	bb_reflection_R13* g_new();
	void mark();
};
class bb_reflection_R14 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R14();
	bb_reflection_R14* g_new();
	void mark();
};
class bb_reflection_R15 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R15();
	bb_reflection_R15* g_new();
	void mark();
};
class bb_reflection_R16 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R16();
	bb_reflection_R16* g_new();
	void mark();
};
class bb_reflection_R10 : public bb_reflection_FunctionInfo{
	public:
	bb_reflection_R10();
	bb_reflection_R10* g_new();
	void mark();
};
class bb_reflection_R11 : public bb_reflection_FunctionInfo{
	public:
	bb_reflection_R11();
	bb_reflection_R11* g_new();
	void mark();
};
class bb_reflection_R17 : public bb_reflection_FunctionInfo{
	public:
	bb_reflection_R17();
	bb_reflection_R17* g_new();
	void mark();
};
class bb_reflection_R19 : public bb_reflection_FieldInfo{
	public:
	bb_reflection_R19();
	bb_reflection_R19* g_new();
	void mark();
};
class bb_reflection_R22 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R22();
	bb_reflection_R22* g_new();
	void mark();
};
class bb_reflection_R23 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R23();
	bb_reflection_R23* g_new();
	void mark();
};
class bb_reflection_R24 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R24();
	bb_reflection_R24* g_new();
	void mark();
};
class bb_reflection_R25 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R25();
	bb_reflection_R25* g_new();
	void mark();
};
class bb_reflection_R26 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R26();
	bb_reflection_R26* g_new();
	void mark();
};
class bb_reflection_R20 : public bb_reflection_FunctionInfo{
	public:
	bb_reflection_R20();
	bb_reflection_R20* g_new();
	void mark();
};
class bb_reflection_R21 : public bb_reflection_FunctionInfo{
	public:
	bb_reflection_R21();
	bb_reflection_R21* g_new();
	void mark();
};
class bb_reflection_R27 : public bb_reflection_FunctionInfo{
	public:
	bb_reflection_R27();
	bb_reflection_R27* g_new();
	void mark();
};
class bb_reflection_R29 : public bb_reflection_FieldInfo{
	public:
	bb_reflection_R29();
	bb_reflection_R29* g_new();
	void mark();
};
class bb_reflection_R33 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R33();
	bb_reflection_R33* g_new();
	void mark();
};
class bb_reflection_R34 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R34();
	bb_reflection_R34* g_new();
	void mark();
};
class bb_reflection_R35 : public bb_reflection_MethodInfo{
	public:
	bb_reflection_R35();
	bb_reflection_R35* g_new();
	void mark();
};
class bb_reflection_R30 : public bb_reflection_FunctionInfo{
	public:
	bb_reflection_R30();
	bb_reflection_R30* g_new();
	void mark();
};
class bb_reflection_R31 : public bb_reflection_FunctionInfo{
	public:
	bb_reflection_R31();
	bb_reflection_R31* g_new();
	void mark();
};
class bb_reflection_R32 : public bb_reflection_FunctionInfo{
	public:
	bb_reflection_R32();
	bb_reflection_R32* g_new();
	void mark();
};
class bb_reflection_R36 : public bb_reflection_FunctionInfo{
	public:
	bb_reflection_R36();
	bb_reflection_R36* g_new();
	void mark();
};
bb_boxes_BoolObject::bb_boxes_BoolObject(){
	f_value=false;
}
bb_boxes_BoolObject* bb_boxes_BoolObject::g_new(bool t_value){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<11>";
	this->f_value=t_value;
	popErr();
	return this;
}
bool bb_boxes_BoolObject::m_ToBool(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<15>";
	popErr();
	return f_value;
}
bool bb_boxes_BoolObject::m_Equals(bb_boxes_BoolObject* t_box){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<19>";
	bool t_=f_value==t_box->f_value;
	popErr();
	return t_;
}
bb_boxes_BoolObject* bb_boxes_BoolObject::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<7>";
	popErr();
	return this;
}
void bb_boxes_BoolObject::mark(){
	Object::mark();
}
bb_boxes_IntObject::bb_boxes_IntObject(){
	f_value=0;
}
bb_boxes_IntObject* bb_boxes_IntObject::g_new(int t_value){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<27>";
	this->f_value=t_value;
	popErr();
	return this;
}
bb_boxes_IntObject* bb_boxes_IntObject::g_new2(Float t_value){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<31>";
	this->f_value=int(t_value);
	popErr();
	return this;
}
int bb_boxes_IntObject::m_ToInt(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<35>";
	popErr();
	return f_value;
}
Float bb_boxes_IntObject::m_ToFloat(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<39>";
	Float t_=Float(f_value);
	popErr();
	return t_;
}
String bb_boxes_IntObject::m_ToString(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<43>";
	String t_=String(f_value);
	popErr();
	return t_;
}
bool bb_boxes_IntObject::m_Equals2(bb_boxes_IntObject* t_box){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<47>";
	bool t_=f_value==t_box->f_value;
	popErr();
	return t_;
}
int bb_boxes_IntObject::m_Compare(bb_boxes_IntObject* t_box){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<51>";
	int t_=f_value-t_box->f_value;
	popErr();
	return t_;
}
bb_boxes_IntObject* bb_boxes_IntObject::g_new3(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<23>";
	popErr();
	return this;
}
void bb_boxes_IntObject::mark(){
	Object::mark();
}
bb_boxes_FloatObject::bb_boxes_FloatObject(){
	f_value=FLOAT(.0);
}
bb_boxes_FloatObject* bb_boxes_FloatObject::g_new(int t_value){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<59>";
	this->f_value=Float(t_value);
	popErr();
	return this;
}
bb_boxes_FloatObject* bb_boxes_FloatObject::g_new2(Float t_value){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<63>";
	this->f_value=t_value;
	popErr();
	return this;
}
int bb_boxes_FloatObject::m_ToInt(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<67>";
	int t_=int(f_value);
	popErr();
	return t_;
}
Float bb_boxes_FloatObject::m_ToFloat(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<71>";
	popErr();
	return f_value;
}
String bb_boxes_FloatObject::m_ToString(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<75>";
	String t_=String(f_value);
	popErr();
	return t_;
}
bool bb_boxes_FloatObject::m_Equals3(bb_boxes_FloatObject* t_box){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<79>";
	bool t_=f_value==t_box->f_value;
	popErr();
	return t_;
}
int bb_boxes_FloatObject::m_Compare2(bb_boxes_FloatObject* t_box){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<83>";
	if(f_value<t_box->f_value){
		errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<83>";
		popErr();
		return -1;
	}
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<84>";
	int t_=((f_value>t_box->f_value)?1:0);
	popErr();
	return t_;
}
bb_boxes_FloatObject* bb_boxes_FloatObject::g_new3(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<55>";
	popErr();
	return this;
}
void bb_boxes_FloatObject::mark(){
	Object::mark();
}
bb_boxes_StringObject::bb_boxes_StringObject(){
	f_value=String();
}
bb_boxes_StringObject* bb_boxes_StringObject::g_new(int t_value){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<92>";
	this->f_value=String(t_value);
	popErr();
	return this;
}
bb_boxes_StringObject* bb_boxes_StringObject::g_new2(Float t_value){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<96>";
	this->f_value=String(t_value);
	popErr();
	return this;
}
bb_boxes_StringObject* bb_boxes_StringObject::g_new3(String t_value){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<100>";
	this->f_value=t_value;
	popErr();
	return this;
}
String bb_boxes_StringObject::m_ToString(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<104>";
	popErr();
	return f_value;
}
bool bb_boxes_StringObject::m_Equals4(bb_boxes_StringObject* t_box){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<108>";
	bool t_=f_value==t_box->f_value;
	popErr();
	return t_;
}
int bb_boxes_StringObject::m_Compare3(bb_boxes_StringObject* t_box){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<112>";
	int t_=f_value.Compare(t_box->f_value);
	popErr();
	return t_;
}
bb_boxes_StringObject* bb_boxes_StringObject::g_new4(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/boxes.monkey<88>";
	popErr();
	return this;
}
void bb_boxes_StringObject::mark(){
	Object::mark();
}
bb_reflection_ClassInfo::bb_reflection_ClassInfo(){
	f__name=String();
	f__attrs=0;
	f__sclass=0;
	f__ifaces=Array<bb_reflection_ClassInfo* >();
	f__fields=Array<bb_reflection_FieldInfo* >();
	f__methods=Array<bb_reflection_MethodInfo* >();
	f__ctors=Array<bb_reflection_FunctionInfo* >();
}
bb_reflection_ClassInfo* bb_reflection_ClassInfo::g_new(String t_name,int t_attrs,bb_reflection_ClassInfo* t_sclass,Array<bb_reflection_ClassInfo* > t_ifaces){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<257>";
	f__name=t_name;
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<258>";
	f__attrs=t_attrs;
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<259>";
	gc_assign(f__sclass,t_sclass);
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<260>";
	gc_assign(f__ifaces,t_ifaces);
	popErr();
	return this;
}
bb_reflection_ClassInfo* bb_reflection_ClassInfo::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<254>";
	popErr();
	return this;
}
int bb_reflection_ClassInfo::m_Init(){
	pushErr();
	popErr();
	return 0;
}
void bb_reflection_ClassInfo::mark(){
	Object::mark();
	gc_mark_q(f__sclass);
	gc_mark_q(f__ifaces);
	gc_mark_q(f__fields);
	gc_mark_q(f__methods);
	gc_mark_q(f__ctors);
}
Array<bb_reflection_ClassInfo* > bb_reflection__classes;
bb_reflection_R2::bb_reflection_R2(){
}
bb_reflection_R2* bb_reflection_R2::g_new(){
	bb_reflection_ClassInfo::g_new(String(L"monkey.boxes.BoolObject"),0,bb_reflection__unknownClass,Array<bb_reflection_ClassInfo* >());
	gc_assign(bb_reflection__boolClass,(this));
	return this;
}
int bb_reflection_R2::m_Init(){
	gc_assign(f__fields,Array<bb_reflection_FieldInfo* >(1));
	gc_assign(f__fields.At(0),((new bb_reflection_R3)->g_new()));
	gc_assign(f__methods,Array<bb_reflection_MethodInfo* >(2));
	gc_assign(f__methods.At(0),((new bb_reflection_R5)->g_new()));
	gc_assign(f__methods.At(1),((new bb_reflection_R6)->g_new()));
	gc_assign(f__ctors,Array<bb_reflection_FunctionInfo* >(2));
	gc_assign(f__ctors.At(0),((new bb_reflection_R4)->g_new()));
	gc_assign(f__ctors.At(1),((new bb_reflection_R7)->g_new()));
	return 0;
}
void bb_reflection_R2::mark(){
	bb_reflection_ClassInfo::mark();
}
bb_reflection_UnknownClass::bb_reflection_UnknownClass(){
}
bb_reflection_UnknownClass* bb_reflection_UnknownClass::g_new(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<599>";
	bb_reflection_ClassInfo::g_new(String(L"?"),0,0,Array<bb_reflection_ClassInfo* >());
	popErr();
	return this;
}
void bb_reflection_UnknownClass::mark(){
	bb_reflection_ClassInfo::mark();
}
bb_reflection_ClassInfo* bb_reflection__unknownClass;
bb_reflection_ClassInfo* bb_reflection__boolClass;
bb_reflection_R8::bb_reflection_R8(){
}
bb_reflection_R8* bb_reflection_R8::g_new(){
	bb_reflection_ClassInfo::g_new(String(L"monkey.boxes.IntObject"),0,bb_reflection__unknownClass,Array<bb_reflection_ClassInfo* >());
	gc_assign(bb_reflection__intClass,(this));
	return this;
}
int bb_reflection_R8::m_Init(){
	gc_assign(f__fields,Array<bb_reflection_FieldInfo* >(1));
	gc_assign(f__fields.At(0),((new bb_reflection_R9)->g_new()));
	gc_assign(f__methods,Array<bb_reflection_MethodInfo* >(5));
	gc_assign(f__methods.At(0),((new bb_reflection_R12)->g_new()));
	gc_assign(f__methods.At(1),((new bb_reflection_R13)->g_new()));
	gc_assign(f__methods.At(2),((new bb_reflection_R14)->g_new()));
	gc_assign(f__methods.At(3),((new bb_reflection_R15)->g_new()));
	gc_assign(f__methods.At(4),((new bb_reflection_R16)->g_new()));
	gc_assign(f__ctors,Array<bb_reflection_FunctionInfo* >(3));
	gc_assign(f__ctors.At(0),((new bb_reflection_R10)->g_new()));
	gc_assign(f__ctors.At(1),((new bb_reflection_R11)->g_new()));
	gc_assign(f__ctors.At(2),((new bb_reflection_R17)->g_new()));
	return 0;
}
void bb_reflection_R8::mark(){
	bb_reflection_ClassInfo::mark();
}
bb_reflection_ClassInfo* bb_reflection__intClass;
bb_reflection_R18::bb_reflection_R18(){
}
bb_reflection_R18* bb_reflection_R18::g_new(){
	bb_reflection_ClassInfo::g_new(String(L"monkey.boxes.FloatObject"),0,bb_reflection__unknownClass,Array<bb_reflection_ClassInfo* >());
	gc_assign(bb_reflection__floatClass,(this));
	return this;
}
int bb_reflection_R18::m_Init(){
	gc_assign(f__fields,Array<bb_reflection_FieldInfo* >(1));
	gc_assign(f__fields.At(0),((new bb_reflection_R19)->g_new()));
	gc_assign(f__methods,Array<bb_reflection_MethodInfo* >(5));
	gc_assign(f__methods.At(0),((new bb_reflection_R22)->g_new()));
	gc_assign(f__methods.At(1),((new bb_reflection_R23)->g_new()));
	gc_assign(f__methods.At(2),((new bb_reflection_R24)->g_new()));
	gc_assign(f__methods.At(3),((new bb_reflection_R25)->g_new()));
	gc_assign(f__methods.At(4),((new bb_reflection_R26)->g_new()));
	gc_assign(f__ctors,Array<bb_reflection_FunctionInfo* >(3));
	gc_assign(f__ctors.At(0),((new bb_reflection_R20)->g_new()));
	gc_assign(f__ctors.At(1),((new bb_reflection_R21)->g_new()));
	gc_assign(f__ctors.At(2),((new bb_reflection_R27)->g_new()));
	return 0;
}
void bb_reflection_R18::mark(){
	bb_reflection_ClassInfo::mark();
}
bb_reflection_ClassInfo* bb_reflection__floatClass;
bb_reflection_R28::bb_reflection_R28(){
}
bb_reflection_R28* bb_reflection_R28::g_new(){
	bb_reflection_ClassInfo::g_new(String(L"monkey.boxes.StringObject"),0,bb_reflection__unknownClass,Array<bb_reflection_ClassInfo* >());
	gc_assign(bb_reflection__stringClass,(this));
	return this;
}
int bb_reflection_R28::m_Init(){
	gc_assign(f__fields,Array<bb_reflection_FieldInfo* >(1));
	gc_assign(f__fields.At(0),((new bb_reflection_R29)->g_new()));
	gc_assign(f__methods,Array<bb_reflection_MethodInfo* >(3));
	gc_assign(f__methods.At(0),((new bb_reflection_R33)->g_new()));
	gc_assign(f__methods.At(1),((new bb_reflection_R34)->g_new()));
	gc_assign(f__methods.At(2),((new bb_reflection_R35)->g_new()));
	gc_assign(f__ctors,Array<bb_reflection_FunctionInfo* >(4));
	gc_assign(f__ctors.At(0),((new bb_reflection_R30)->g_new()));
	gc_assign(f__ctors.At(1),((new bb_reflection_R31)->g_new()));
	gc_assign(f__ctors.At(2),((new bb_reflection_R32)->g_new()));
	gc_assign(f__ctors.At(3),((new bb_reflection_R36)->g_new()));
	return 0;
}
void bb_reflection_R28::mark(){
	bb_reflection_ClassInfo::mark();
}
bb_reflection_ClassInfo* bb_reflection__stringClass;
bb_reflection__GetClass::bb_reflection__GetClass(){
}
bb_reflection__GetClass* bb_reflection__GetClass::g_new(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<582>";
	popErr();
	return this;
}
void bb_reflection__GetClass::mark(){
	Object::mark();
}
bb_reflection___GetClass::bb_reflection___GetClass(){
}
bb_reflection___GetClass* bb_reflection___GetClass::g_new(){
	pushErr();
	errInfo="$SOURCE<361>";
	bb_reflection__GetClass::g_new();
	errInfo="$SOURCE<361>";
	popErr();
	return this;
}
void bb_reflection___GetClass::mark(){
	bb_reflection__GetClass::mark();
}
bb_reflection__GetClass* bb_reflection__getClass;
int bb_reflection___init(){
	gc_assign(bb_reflection__classes,Array<bb_reflection_ClassInfo* >(4));
	gc_assign(bb_reflection__classes.At(0),((new bb_reflection_R2)->g_new()));
	gc_assign(bb_reflection__classes.At(1),((new bb_reflection_R8)->g_new()));
	gc_assign(bb_reflection__classes.At(2),((new bb_reflection_R18)->g_new()));
	gc_assign(bb_reflection__classes.At(3),((new bb_reflection_R28)->g_new()));
	bb_reflection__classes.At(0)->m_Init();
	bb_reflection__classes.At(1)->m_Init();
	bb_reflection__classes.At(2)->m_Init();
	bb_reflection__classes.At(3)->m_Init();
	gc_assign(bb_reflection__getClass,((new bb_reflection___GetClass)->g_new()));
	return 0;
}
int bb_reflection__init;
String bb_Harpl_AppString(){
	pushErr();
	errInfo="C:/harpl-project/Harpl.monkey<20>";
	errInfo="C:/harpl-project/Harpl.monkey<20>";
	popErr();
	return String(L"Harpl compiler 00.00.00-A");
}
int bb_Harpl_ShowCommandLineArgs(){
	pushErr();
	errInfo="C:/harpl-project/Harpl.monkey<53>";
	Print(String(L"Syntax: HARPL [filename]"));
	errInfo="C:/harpl-project/Harpl.monkey<54>";
	popErr();
	return 1;
}
void bb_Harpl_AbortExecution(String t_message,int t_errorLevel){
	pushErr();
	errInfo="C:/harpl-project/Harpl.monkey<59>";
	Print(String(L"Error: ")+t_message);
	errInfo="C:/harpl-project/Harpl.monkey<60>";
	Print(String(L"Execution of Harpl compiler has been canceled."));
	errInfo="C:/harpl-project/Harpl.monkey<61>";
	ExitApp(t_errorLevel);
	popErr();
}
bb_compiler_Compiler::bb_compiler_Compiler(){
	f_compileErrors=(new bb_list_List)->g_new();
	f_lexer=(new bb_lexer_Lexer)->g_new();
}
bb_compiler_Compiler* bb_compiler_Compiler::g_new(){
	pushErr();
	errInfo="C:/harpl-project/compiler/compiler.monkey<12>";
	popErr();
	return this;
}
int bb_compiler_Compiler::m_AddError(String t_description,String t_file,int t_posX,int t_posY){
	pushErr();
	errInfo="C:/harpl-project/compiler/compiler.monkey<49>";
	if(f_compileErrors==0){
		errInfo="C:/harpl-project/compiler/compiler.monkey<49>";
		gc_assign(f_compileErrors,(new bb_list_List)->g_new());
	}
	errInfo="C:/harpl-project/compiler/compiler.monkey<50>";
	bb_compiler_CompileError* t_err=(new bb_compiler_CompileError)->g_new();
	errInfo="C:/harpl-project/compiler/compiler.monkey<51>";
	t_err->f_description=t_description;
	errInfo="C:/harpl-project/compiler/compiler.monkey<52>";
	t_err->f_file=t_file;
	errInfo="C:/harpl-project/compiler/compiler.monkey<53>";
	t_err->f_posX=t_posX;
	errInfo="C:/harpl-project/compiler/compiler.monkey<54>";
	t_err->f_posY=t_posY;
	errInfo="C:/harpl-project/compiler/compiler.monkey<55>";
	f_compileErrors->m_AddLast(t_err);
	popErr();
	return 0;
}
bool bb_compiler_Compiler::m_CompileFile(String t_filename){
	pushErr();
	errInfo="C:/harpl-project/compiler/compiler.monkey<28>";
	if(FileType(t_filename)!=1){
		errInfo="C:/harpl-project/compiler/compiler.monkey<29>";
		m_AddError(String(L"File ")+t_filename+String(L" was not found."),String(),-1,-1);
		errInfo="C:/harpl-project/compiler/compiler.monkey<30>";
		popErr();
		return false;
	}
	errInfo="C:/harpl-project/compiler/compiler.monkey<33>";
	String t_txtStream=LoadString(t_filename);
	errInfo="C:/harpl-project/compiler/compiler.monkey<35>";
	if(t_txtStream==String()){
		errInfo="C:/harpl-project/compiler/compiler.monkey<35>";
		m_AddError(String(L"File ")+t_filename+String(L" is empty."),t_filename,0,0);
	}
	errInfo="C:/harpl-project/compiler/compiler.monkey<37>";
	gc_assign(f_lexer,(new bb_lexer_Lexer)->g_new());
	errInfo="C:/harpl-project/compiler/compiler.monkey<39>";
	if(f_lexer->m_Tokenize(t_txtStream,this,t_filename)==0){
		errInfo="C:/harpl-project/compiler/compiler.monkey<39>";
		popErr();
		return false;
	}
	errInfo="C:/harpl-project/compiler/compiler.monkey<41>";
	if(this->f_compileErrors->m_IsEmpty()==false){
		errInfo="C:/harpl-project/compiler/compiler.monkey<42>";
		popErr();
		return false;
	}else{
		errInfo="C:/harpl-project/compiler/compiler.monkey<44>";
		popErr();
		return true;
	}
}
void bb_compiler_Compiler::mark(){
	Object::mark();
	gc_mark_q(f_compileErrors);
	gc_mark_q(f_lexer);
}
bb_compiler_CompileError::bb_compiler_CompileError(){
	f_description=String();
	f_file=String();
	f_posX=0;
	f_posY=0;
}
bb_compiler_CompileError* bb_compiler_CompileError::g_new(){
	pushErr();
	errInfo="C:/harpl-project/compiler/compiler.monkey<68>";
	popErr();
	return this;
}
void bb_compiler_CompileError::mark(){
	Object::mark();
}
bb_list_List::bb_list_List(){
	f__head=((new bb_list_HeadNode)->g_new());
}
bb_list_List* bb_list_List::g_new(){
	pushErr();
	popErr();
	return this;
}
bb_list_Node* bb_list_List::m_AddLast(bb_compiler_CompileError* t_data){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<120>";
	bb_list_Node* t_=(new bb_list_Node)->g_new(f__head,f__head->f__pred,t_data);
	popErr();
	return t_;
}
bb_list_List* bb_list_List::g_new2(Array<bb_compiler_CompileError* > t_data){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	Array<bb_compiler_CompileError* > t_=t_data;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	int t_2=0;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	while(t_2<t_.Length()){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
		bb_compiler_CompileError* t_t=t_.At(t_2);
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
		t_2=t_2+1;
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<14>";
		m_AddLast(t_t);
	}
	popErr();
	return this;
}
bool bb_list_List::m_IsEmpty(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<50>";
	bool t_=f__head->f__succ==f__head;
	popErr();
	return t_;
}
bb_list_Enumerator2* bb_list_List::m_ObjectEnumerator(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<124>";
	bb_list_Enumerator2* t_=(new bb_list_Enumerator2)->g_new(this);
	popErr();
	return t_;
}
void bb_list_List::mark(){
	Object::mark();
	gc_mark_q(f__head);
}
bb_list_Node::bb_list_Node(){
	f__succ=0;
	f__pred=0;
	f__data=0;
}
bb_list_Node* bb_list_Node::g_new(bb_list_Node* t_succ,bb_list_Node* t_pred,bb_compiler_CompileError* t_data){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<199>";
	gc_assign(f__succ,t_succ);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<200>";
	gc_assign(f__pred,t_pred);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<201>";
	gc_assign(f__succ->f__pred,this);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<202>";
	gc_assign(f__pred->f__succ,this);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<203>";
	gc_assign(f__data,t_data);
	popErr();
	return this;
}
bb_list_Node* bb_list_Node::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<196>";
	popErr();
	return this;
}
void bb_list_Node::mark(){
	Object::mark();
	gc_mark_q(f__succ);
	gc_mark_q(f__pred);
	gc_mark_q(f__data);
}
bb_list_HeadNode::bb_list_HeadNode(){
}
bb_list_HeadNode* bb_list_HeadNode::g_new(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<248>";
	bb_list_Node::g_new2();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<249>";
	gc_assign(f__succ,(this));
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<250>";
	gc_assign(f__pred,(this));
	popErr();
	return this;
}
void bb_list_HeadNode::mark(){
	bb_list_Node::mark();
}
bb_lexer_Lexer::bb_lexer_Lexer(){
	f_tokens=(new bb_list_List2)->g_new();
}
bb_lexer_Lexer* bb_lexer_Lexer::g_new(){
	pushErr();
	errInfo="C:/harpl-project/compiler/lexer.monkey<11>";
	popErr();
	return this;
}
int bb_lexer_Lexer::m_Tokenize(String t_txtStream,bb_compiler_Compiler* t_compiler,String t_sourceFile){
	pushErr();
	errInfo="C:/harpl-project/compiler/lexer.monkey<25>";
	bb_byref_BoolByRef* t_boolRef=(new bb_byref_BoolByRef)->g_new();
	errInfo="C:/harpl-project/compiler/lexer.monkey<26>";
	if(f_tokens==0){
		errInfo="C:/harpl-project/compiler/lexer.monkey<26>";
		gc_assign(f_tokens,(new bb_list_List2)->g_new());
	}
	errInfo="C:/harpl-project/compiler/lexer.monkey<28>";
	f_tokens->m_Clear();
	errInfo="C:/harpl-project/compiler/lexer.monkey<30>";
	int t_i=0;
	errInfo="C:/harpl-project/compiler/lexer.monkey<30>";
	int t_lastOffset=0;
	errInfo="C:/harpl-project/compiler/lexer.monkey<30>";
	int t_lineNum=0;
	errInfo="C:/harpl-project/compiler/lexer.monkey<31>";
	Print(String(L"Tokenizing..."));
	errInfo="C:/harpl-project/compiler/lexer.monkey<32>";
	while(t_i<t_txtStream.Length()){
		errInfo="C:/harpl-project/compiler/lexer.monkey<35>";
		int t_char=(int)t_txtStream[t_i];
		errInfo="C:/harpl-project/compiler/lexer.monkey<38>";
		if(t_char>=97 && t_char<=122 || t_char>=65 && t_char<=90){
			errInfo="C:/harpl-project/compiler/lexer.monkey<39>";
			bool t_done=false;
			errInfo="C:/harpl-project/compiler/lexer.monkey<40>";
			t_done=false;
			errInfo="C:/harpl-project/compiler/lexer.monkey<41>";
			int t_tokenInit=t_i;
			errInfo="C:/harpl-project/compiler/lexer.monkey<42>";
			while(t_i<t_txtStream.Length() && t_done==false){
				errInfo="C:/harpl-project/compiler/lexer.monkey<43>";
				if(bb_lexer_IsAValidIdentifierChar((int)t_txtStream[t_i])==false){
					errInfo="C:/harpl-project/compiler/lexer.monkey<43>";
					t_done=true;
				}else{
					errInfo="C:/harpl-project/compiler/lexer.monkey<43>";
					t_i+=1;
				}
			}
			errInfo="C:/harpl-project/compiler/lexer.monkey<45>";
			bb_token_Token* t_token=(new bb_token_Token)->g_new(t_sourceFile,t_tokenInit-t_lastOffset,t_lineNum,t_txtStream.Slice(t_tokenInit,t_i),1);
			errInfo="C:/harpl-project/compiler/lexer.monkey<46>";
			f_tokens->m_AddLast2(t_token);
			errInfo="C:/harpl-project/compiler/lexer.monkey<47>";
			t_i-=1;
		}else{
			errInfo="C:/harpl-project/compiler/lexer.monkey<50>";
			if(t_char>=48 && t_char<=57){
				errInfo="C:/harpl-project/compiler/lexer.monkey<51>";
				bool t_done2=false;
				errInfo="C:/harpl-project/compiler/lexer.monkey<51>";
				bool t_hasdot=false;
				errInfo="C:/harpl-project/compiler/lexer.monkey<52>";
				t_done2=false;
				errInfo="C:/harpl-project/compiler/lexer.monkey<53>";
				int t_tokenInit2=t_i;
				errInfo="C:/harpl-project/compiler/lexer.monkey<54>";
				while(t_i<t_txtStream.Length() && t_done2==false){
					errInfo="C:/harpl-project/compiler/lexer.monkey<55>";
					if((int)t_txtStream[t_i]>=48 && String((int)t_txtStream[t_i])<=String(L"9")){
						errInfo="C:/harpl-project/compiler/lexer.monkey<56>";
						t_i+=1;
					}else{
						errInfo="C:/harpl-project/compiler/lexer.monkey<57>";
						if((int)t_txtStream[t_i]==46){
							errInfo="C:/harpl-project/compiler/lexer.monkey<58>";
							if(t_hasdot==false){
								errInfo="C:/harpl-project/compiler/lexer.monkey<59>";
								t_hasdot=true;
								errInfo="C:/harpl-project/compiler/lexer.monkey<60>";
								t_i+=1;
							}else{
								errInfo="C:/harpl-project/compiler/lexer.monkey<62>";
								t_compiler->m_AddError(String(L"Malformed numeric literal"),t_sourceFile,t_tokenInit2-t_lastOffset,t_lineNum);
								errInfo="C:/harpl-project/compiler/lexer.monkey<63>";
								t_done2=true;
							}
						}else{
							errInfo="C:/harpl-project/compiler/lexer.monkey<66>";
							t_done2=true;
						}
					}
				}
				errInfo="C:/harpl-project/compiler/lexer.monkey<69>";
				bb_token_Token* t_token2=(new bb_token_Token)->g_new(t_sourceFile,t_tokenInit2-t_lastOffset,t_lineNum,t_txtStream.Slice(t_tokenInit2,t_i),4);
				errInfo="C:/harpl-project/compiler/lexer.monkey<70>";
				f_tokens->m_AddLast2(t_token2);
				errInfo="C:/harpl-project/compiler/lexer.monkey<71>";
				t_i-=1;
			}else{
				errInfo="C:/harpl-project/compiler/lexer.monkey<74>";
				if(t_char==35){
					errInfo="C:/harpl-project/compiler/lexer.monkey<75>";
					bool t_done3=false;
					errInfo="C:/harpl-project/compiler/lexer.monkey<76>";
					t_done3=false;
					errInfo="C:/harpl-project/compiler/lexer.monkey<77>";
					int t_tokenInit3=t_i;
					errInfo="C:/harpl-project/compiler/lexer.monkey<78>";
					t_i=t_i+1;
					errInfo="C:/harpl-project/compiler/lexer.monkey<79>";
					while(t_i<t_txtStream.Length() && t_done3==false){
						errInfo="C:/harpl-project/compiler/lexer.monkey<80>";
						if((int)t_txtStream[t_i]>=48 && String((int)t_txtStream[t_i])<=String(L"9") || String((int)t_txtStream[t_i])>=String(L"A") && String((int)t_txtStream[t_i])<=String(L"Z") || String((int)t_txtStream[t_i])>=String(L"a") && String((int)t_txtStream[t_i])<=String(L"z")){
							errInfo="C:/harpl-project/compiler/lexer.monkey<81>";
							t_i+=1;
						}else{
							errInfo="C:/harpl-project/compiler/lexer.monkey<83>";
							t_done3=true;
						}
					}
					errInfo="C:/harpl-project/compiler/lexer.monkey<87>";
					String t_newtext=String(bb_stringutils_HexToInteger(t_txtStream.Slice(t_tokenInit3+1,t_i),t_boolRef));
					errInfo="C:/harpl-project/compiler/lexer.monkey<88>";
					if(t_boolRef->f_value==false){
						errInfo="C:/harpl-project/compiler/lexer.monkey<89>";
						t_compiler->m_AddError(String(L"Malformed HEX identifier: ")+t_txtStream.Slice(t_tokenInit3,t_i),t_sourceFile,t_tokenInit3-t_lastOffset-1,t_lineNum);
					}
					errInfo="C:/harpl-project/compiler/lexer.monkey<91>";
					bb_token_Token* t_token3=(new bb_token_Token)->g_new(t_sourceFile,t_tokenInit3-t_lastOffset,t_lineNum,t_newtext,4);
					errInfo="C:/harpl-project/compiler/lexer.monkey<92>";
					f_tokens->m_AddLast2(t_token3);
					errInfo="C:/harpl-project/compiler/lexer.monkey<93>";
					t_i-=1;
				}else{
					errInfo="C:/harpl-project/compiler/lexer.monkey<97>";
					if(t_char==34){
						errInfo="C:/harpl-project/compiler/lexer.monkey<98>";
						bool t_done4=false;
						errInfo="C:/harpl-project/compiler/lexer.monkey<99>";
						t_done4=false;
						errInfo="C:/harpl-project/compiler/lexer.monkey<100>";
						int t_tokenInit4=t_i+1;
						errInfo="C:/harpl-project/compiler/lexer.monkey<101>";
						t_i+=1;
						errInfo="C:/harpl-project/compiler/lexer.monkey<102>";
						while(t_i<t_txtStream.Length() && t_done4==false){
							errInfo="C:/harpl-project/compiler/lexer.monkey<103>";
							if((int)t_txtStream[t_i]==34){
								errInfo="C:/harpl-project/compiler/lexer.monkey<103>";
								t_done4=true;
							}else{
								errInfo="C:/harpl-project/compiler/lexer.monkey<103>";
								t_i+=1;
							}
						}
						errInfo="C:/harpl-project/compiler/lexer.monkey<105>";
						if(t_done4==false){
							errInfo="C:/harpl-project/compiler/lexer.monkey<106>";
							t_compiler->m_AddError(String(L"Expecting \""),t_sourceFile,t_tokenInit4-t_lastOffset-1,t_lineNum);
						}
						errInfo="C:/harpl-project/compiler/lexer.monkey<108>";
						bb_token_Token* t_token4=(new bb_token_Token)->g_new(t_sourceFile,t_tokenInit4-t_lastOffset-1,t_lineNum,t_txtStream.Slice(t_tokenInit4,t_i),2);
						errInfo="C:/harpl-project/compiler/lexer.monkey<109>";
						t_token4->f_text=bb_lexer_ScapeChars(t_token4->f_text);
						errInfo="C:/harpl-project/compiler/lexer.monkey<110>";
						f_tokens->m_AddLast2(t_token4);
					}else{
						errInfo="C:/harpl-project/compiler/lexer.monkey<113>";
						if(t_char==39){
							errInfo="C:/harpl-project/compiler/lexer.monkey<114>";
							bool t_done5=false;
							errInfo="C:/harpl-project/compiler/lexer.monkey<115>";
							t_done5=false;
							errInfo="C:/harpl-project/compiler/lexer.monkey<116>";
							int t_tokenInit5=t_i+1;
							errInfo="C:/harpl-project/compiler/lexer.monkey<117>";
							t_i+=1;
							errInfo="C:/harpl-project/compiler/lexer.monkey<118>";
							while(t_i<t_txtStream.Length() && t_done5==false){
								errInfo="C:/harpl-project/compiler/lexer.monkey<119>";
								if((int)t_txtStream[t_i]==39){
									errInfo="C:/harpl-project/compiler/lexer.monkey<119>";
									t_done5=true;
								}else{
									errInfo="C:/harpl-project/compiler/lexer.monkey<119>";
									t_i+=1;
								}
							}
							errInfo="C:/harpl-project/compiler/lexer.monkey<121>";
							if(t_done5==false){
								errInfo="C:/harpl-project/compiler/lexer.monkey<122>";
								t_compiler->m_AddError(String(L"Expecting '"),t_sourceFile,t_tokenInit5-t_lastOffset-1,t_lineNum);
							}
							errInfo="C:/harpl-project/compiler/lexer.monkey<124>";
							bb_token_Token* t_token5=(new bb_token_Token)->g_new(t_sourceFile,t_tokenInit5-t_lastOffset-1,t_lineNum,t_txtStream.Slice(t_tokenInit5,t_i),2);
							errInfo="C:/harpl-project/compiler/lexer.monkey<125>";
							t_token5->f_text=bb_lexer_ScapeChars(t_token5->f_text);
							errInfo="C:/harpl-project/compiler/lexer.monkey<126>";
							f_tokens->m_AddLast2(t_token5);
						}else{
							errInfo="C:/harpl-project/compiler/lexer.monkey<129>";
							if(t_char==10 || t_char==13){
								errInfo="C:/harpl-project/compiler/lexer.monkey<130>";
								bb_token_Token* t_token6=(new bb_token_Token)->g_new(t_sourceFile,t_i-t_lastOffset,t_lineNum,t_txtStream.Slice(t_i,t_i+1),32);
								errInfo="C:/harpl-project/compiler/lexer.monkey<131>";
								f_tokens->m_AddLast2(t_token6);
								errInfo="C:/harpl-project/compiler/lexer.monkey<132>";
								if(t_char==10){
									errInfo="C:/harpl-project/compiler/lexer.monkey<133>";
									t_lastOffset=t_i+1;
									errInfo="C:/harpl-project/compiler/lexer.monkey<134>";
									t_lineNum+=1;
								}
							}else{
								errInfo="C:/harpl-project/compiler/lexer.monkey<137>";
								if(t_char==59){
									errInfo="C:/harpl-project/compiler/lexer.monkey<138>";
									bb_token_Token* t_token7=(new bb_token_Token)->g_new(t_sourceFile,t_i-t_lastOffset,t_lineNum,t_txtStream.Slice(t_i,t_i+1),16);
									errInfo="C:/harpl-project/compiler/lexer.monkey<139>";
									f_tokens->m_AddLast2(t_token7);
									errInfo="C:/harpl-project/compiler/lexer.monkey<140>";
									if(t_char==10){
										errInfo="C:/harpl-project/compiler/lexer.monkey<141>";
										t_lastOffset=t_i+1;
										errInfo="C:/harpl-project/compiler/lexer.monkey<142>";
										t_lineNum+=1;
									}
								}else{
									errInfo="C:/harpl-project/compiler/lexer.monkey<148>";
									if(t_char==43 || t_char==45 || t_char==42 || t_char==47 || t_char==37 || t_char==94 || t_char==38 || t_char==124 || t_char==62 || t_char==60 || t_char==61 || t_char==40 || t_char==41 || t_char==91 || t_char==93 || t_char==46){
										errInfo="C:/harpl-project/compiler/lexer.monkey<149>";
										bb_token_Token* t_token8=(new bb_token_Token)->g_new(t_sourceFile,t_i-t_lastOffset,t_lineNum,t_txtStream.Slice(t_i,t_i+1),8);
										errInfo="C:/harpl-project/compiler/lexer.monkey<150>";
										f_tokens->m_AddLast2(t_token8);
									}else{
										errInfo="C:/harpl-project/compiler/lexer.monkey<153>";
										if(t_char==32 || t_char==9){
										}else{
											errInfo="C:/harpl-project/compiler/lexer.monkey<156>";
											if(t_char==33){
												errInfo="C:/harpl-project/compiler/lexer.monkey<157>";
												bool t_done6=false;
												errInfo="C:/harpl-project/compiler/lexer.monkey<158>";
												t_done6=false;
												errInfo="C:/harpl-project/compiler/lexer.monkey<159>";
												t_i+=1;
												errInfo="C:/harpl-project/compiler/lexer.monkey<160>";
												while(t_i<t_txtStream.Length() && t_done6==false){
													errInfo="C:/harpl-project/compiler/lexer.monkey<161>";
													if((int)t_txtStream[t_i]==10 || (int)t_txtStream[t_i]==13){
														errInfo="C:/harpl-project/compiler/lexer.monkey<161>";
														t_done6=true;
													}else{
														errInfo="C:/harpl-project/compiler/lexer.monkey<161>";
														t_i+=1;
													}
												}
											}else{
												errInfo="C:/harpl-project/compiler/lexer.monkey<166>";
												t_compiler->m_AddError(String(L"Syntax error. Unexpected character: ")+String((Char)(t_char),1),t_sourceFile,t_i-t_lastOffset,t_lineNum);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		errInfo="C:/harpl-project/compiler/lexer.monkey<169>";
		t_i+=1;
	}
	errInfo="C:/harpl-project/compiler/lexer.monkey<173>";
	bb_list_Node2* t_node=f_tokens->m_FirstNode();
	errInfo="C:/harpl-project/compiler/lexer.monkey<225>";
	do{
		errInfo="C:/harpl-project/compiler/lexer.monkey<175>";
		bb_token_Token* t_token9=t_node->m_Value();
		errInfo="C:/harpl-project/compiler/lexer.monkey<176>";
		int t_1=t_token9->m_Kind();
		errInfo="C:/harpl-project/compiler/lexer.monkey<177>";
		if(t_1==8){
			errInfo="C:/harpl-project/compiler/lexer.monkey<179>";
			if(t_token9->f_text==String(L".")){
				errInfo="C:/harpl-project/compiler/lexer.monkey<180>";
				bb_list_Node2* t_nextnode=t_node->m_NextNode();
				errInfo="C:/harpl-project/compiler/lexer.monkey<181>";
				if(t_nextnode!=0){
					errInfo="C:/harpl-project/compiler/lexer.monkey<182>";
					if(t_nextnode->m_Value()->m_Kind()==4 && t_nextnode->m_Value()->f_text.Contains(String(L"."))==false){
						errInfo="C:/harpl-project/compiler/lexer.monkey<183>";
						t_token9->f_text=String(L"0")+t_token9->f_text+t_nextnode->m_Value()->f_text;
						errInfo="C:/harpl-project/compiler/lexer.monkey<184>";
						t_token9->m_Kind2(4);
						errInfo="C:/harpl-project/compiler/lexer.monkey<185>";
						t_nextnode->m_Remove();
					}
				}
			}else{
				errInfo="C:/harpl-project/compiler/lexer.monkey<190>";
				if(t_token9->f_text==String(L">") || t_token9->f_text==String(L"<")){
					errInfo="C:/harpl-project/compiler/lexer.monkey<191>";
					bb_list_Node2* t_nextnode2=t_node->m_NextNode();
					errInfo="C:/harpl-project/compiler/lexer.monkey<192>";
					if(t_nextnode2!=0){
						errInfo="C:/harpl-project/compiler/lexer.monkey<195>";
						if((t_nextnode2->m_Value()->f_text==String(L"=") || t_nextnode2->m_Value()->f_text==String(L">") || t_nextnode2->m_Value()->f_text==String(L"<")) && t_nextnode2->m_Value()->m_Kind()==8 && t_nextnode2->m_Value()->f_text!=t_node->m_Value()->f_text){
							errInfo="C:/harpl-project/compiler/lexer.monkey<196>";
							t_token9->f_text=t_token9->f_text+t_nextnode2->m_Value()->f_text;
							errInfo="C:/harpl-project/compiler/lexer.monkey<197>";
							t_nextnode2->m_Remove();
						}
					}
				}
			}
		}else{
			errInfo="C:/harpl-project/compiler/lexer.monkey<202>";
			if(t_1==4){
				errInfo="C:/harpl-project/compiler/lexer.monkey<203>";
				bb_list_Node2* t_prevNode=t_node->m_PrevNode();
				errInfo="C:/harpl-project/compiler/lexer.monkey<204>";
				if(t_prevNode!=0 && t_prevNode->m_Value()->m_Kind()==8){
					errInfo="C:/harpl-project/compiler/lexer.monkey<205>";
					bb_list_Node2* t_grandpaNode=t_prevNode->m_PrevNode();
					errInfo="C:/harpl-project/compiler/lexer.monkey<206>";
					if(t_grandpaNode!=0 && t_grandpaNode->m_Value()->m_Kind()==8){
						errInfo="C:/harpl-project/compiler/lexer.monkey<207>";
						if(t_prevNode->m_Value()->f_text==String(L"-")){
							errInfo="C:/harpl-project/compiler/lexer.monkey<208>";
							if((int)t_token9->f_text[0]!=45){
								errInfo="C:/harpl-project/compiler/lexer.monkey<209>";
								t_token9->f_text=String(L"-")+t_token9->f_text;
							}else{
								errInfo="C:/harpl-project/compiler/lexer.monkey<211>";
								t_token9->f_text=bb_retro_Mid2(t_token9->f_text,2);
							}
							errInfo="C:/harpl-project/compiler/lexer.monkey<213>";
							t_prevNode->m_Remove();
							errInfo="C:/harpl-project/compiler/lexer.monkey<214>";
							t_node=t_node->m_PrevNode();
						}else{
							errInfo="C:/harpl-project/compiler/lexer.monkey<215>";
							if(t_prevNode->m_Value()->f_text==String(L"+")){
								errInfo="C:/harpl-project/compiler/lexer.monkey<216>";
								t_prevNode->m_Remove();
								errInfo="C:/harpl-project/compiler/lexer.monkey<217>";
								t_node=t_node->m_PrevNode();
							}
						}
					}
				}
			}
		}
		errInfo="C:/harpl-project/compiler/lexer.monkey<224>";
		t_node=t_node->m_NextNode();
	}while(!(t_node==0));
	errInfo="C:/harpl-project/compiler/lexer.monkey<227>";
	errInfo="C:/harpl-project/compiler/lexer.monkey<227>";
	bb_list_Enumerator* t_=f_tokens->m_ObjectEnumerator();
	errInfo="C:/harpl-project/compiler/lexer.monkey<227>";
	while(t_->m_HasNext()){
		errInfo="C:/harpl-project/compiler/lexer.monkey<227>";
		bb_token_Token* t_t=t_->m_NextObject();
		errInfo="C:/harpl-project/compiler/lexer.monkey<228>";
		Print(String(L"$")+t_t->f_text+String(L"$ ")+String(t_t->f_docX)+String(L",")+String(t_t->f_docY));
	}
	errInfo="C:/harpl-project/compiler/lexer.monkey<230>";
	popErr();
	return 1;
}
void bb_lexer_Lexer::mark(){
	Object::mark();
	gc_mark_q(f_tokens);
}
bb_byref_BoolByRef::bb_byref_BoolByRef(){
	f_value=false;
}
bb_byref_BoolByRef* bb_byref_BoolByRef::g_new(){
	pushErr();
	errInfo="C:/harpl-project/utils/byref.monkey<2>";
	popErr();
	return this;
}
void bb_byref_BoolByRef::mark(){
	Object::mark();
}
bb_token_Token::bb_token_Token(){
	f_sourceFile=String();
	f__kind=0;
	f_docX=0;
	f_docY=0;
	f_text=String();
}
int bb_token_Token::m_Kind(){
	pushErr();
	errInfo="C:/harpl-project/compiler/token.monkey<24>";
	popErr();
	return f__kind;
}
void bb_token_Token::m_Kind2(int t_value){
	pushErr();
	errInfo="C:/harpl-project/compiler/token.monkey<28>";
	f__kind=t_value;
	popErr();
}
bb_token_Token* bb_token_Token::g_new(String t_sourceDocument,int t_x,int t_y,String t_text,int t_kind){
	pushErr();
	errInfo="C:/harpl-project/compiler/token.monkey<32>";
	this->f_sourceFile=t_sourceDocument;
	errInfo="C:/harpl-project/compiler/token.monkey<33>";
	this->m_Kind2(t_kind);
	errInfo="C:/harpl-project/compiler/token.monkey<34>";
	this->f_docX=t_x;
	errInfo="C:/harpl-project/compiler/token.monkey<35>";
	this->f_docY=t_y;
	errInfo="C:/harpl-project/compiler/token.monkey<36>";
	this->f_text=t_text;
	popErr();
	return this;
}
bb_token_Token* bb_token_Token::g_new2(){
	pushErr();
	errInfo="C:/harpl-project/compiler/token.monkey<5>";
	popErr();
	return this;
}
void bb_token_Token::mark(){
	Object::mark();
}
bb_list_List2::bb_list_List2(){
	f__head=((new bb_list_HeadNode2)->g_new());
}
bb_list_List2* bb_list_List2::g_new(){
	pushErr();
	popErr();
	return this;
}
bb_list_Node2* bb_list_List2::m_AddLast2(bb_token_Token* t_data){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<120>";
	bb_list_Node2* t_=(new bb_list_Node2)->g_new(f__head,f__head->f__pred,t_data);
	popErr();
	return t_;
}
bb_list_List2* bb_list_List2::g_new2(Array<bb_token_Token* > t_data){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	Array<bb_token_Token* > t_=t_data;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	int t_2=0;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	while(t_2<t_.Length()){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
		bb_token_Token* t_t=t_.At(t_2);
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
		t_2=t_2+1;
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<14>";
		m_AddLast2(t_t);
	}
	popErr();
	return this;
}
int bb_list_List2::m_Clear(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<36>";
	gc_assign(f__head->f__succ,f__head);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<37>";
	gc_assign(f__head->f__pred,f__head);
	popErr();
	return 0;
}
bb_list_Node2* bb_list_List2::m_FirstNode(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<62>";
	bb_list_Node2* t_=f__head->m_NextNode();
	popErr();
	return t_;
}
bb_list_Enumerator* bb_list_List2::m_ObjectEnumerator(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<124>";
	bb_list_Enumerator* t_=(new bb_list_Enumerator)->g_new(this);
	popErr();
	return t_;
}
void bb_list_List2::mark(){
	Object::mark();
	gc_mark_q(f__head);
}
bb_list_Node2::bb_list_Node2(){
	f__succ=0;
	f__pred=0;
	f__data=0;
}
bb_list_Node2* bb_list_Node2::g_new(bb_list_Node2* t_succ,bb_list_Node2* t_pred,bb_token_Token* t_data){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<199>";
	gc_assign(f__succ,t_succ);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<200>";
	gc_assign(f__pred,t_pred);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<201>";
	gc_assign(f__succ->f__pred,this);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<202>";
	gc_assign(f__pred->f__succ,this);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<203>";
	gc_assign(f__data,t_data);
	popErr();
	return this;
}
bb_list_Node2* bb_list_Node2::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<196>";
	popErr();
	return this;
}
bb_list_Node2* bb_list_Node2::m_GetNode(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<239>";
	popErr();
	return this;
}
bb_list_Node2* bb_list_Node2::m_NextNode(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<220>";
	if(f__succ->f__pred!=this){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<220>";
		Error(String(L"Illegal operation on removed node"));
	}
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<222>";
	bb_list_Node2* t_=f__succ->m_GetNode();
	popErr();
	return t_;
}
bb_token_Token* bb_list_Node2::m_Value(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<207>";
	popErr();
	return f__data;
}
int bb_list_Node2::m_Remove(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<212>";
	if(f__succ->f__pred!=this){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<212>";
		Error(String(L"Illegal operation on removed node"));
	}
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<214>";
	gc_assign(f__succ->f__pred,f__pred);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<215>";
	gc_assign(f__pred->f__succ,f__succ);
	popErr();
	return 0;
}
bb_list_Node2* bb_list_Node2::m_PrevNode(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<227>";
	if(f__succ->f__pred!=this){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<227>";
		Error(String(L"Illegal operation on removed node"));
	}
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<229>";
	bb_list_Node2* t_=f__pred->m_GetNode();
	popErr();
	return t_;
}
void bb_list_Node2::mark(){
	Object::mark();
	gc_mark_q(f__succ);
	gc_mark_q(f__pred);
	gc_mark_q(f__data);
}
bb_list_HeadNode2::bb_list_HeadNode2(){
}
bb_list_HeadNode2* bb_list_HeadNode2::g_new(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<248>";
	bb_list_Node2::g_new2();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<249>";
	gc_assign(f__succ,(this));
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<250>";
	gc_assign(f__pred,(this));
	popErr();
	return this;
}
bb_list_Node2* bb_list_HeadNode2::m_GetNode(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<254>";
	popErr();
	return 0;
}
void bb_list_HeadNode2::mark(){
	bb_list_Node2::mark();
}
bool bb_lexer_IsAValidIdentifierChar(int t_char){
	pushErr();
	errInfo="C:/harpl-project/compiler/lexer.monkey<236>";
	if(t_char>=97 && t_char<=122 || t_char>=65 && t_char<=90 || t_char==95 || t_char>=48 && t_char<=57){
		errInfo="C:/harpl-project/compiler/lexer.monkey<237>";
		popErr();
		return true;
	}else{
		errInfo="C:/harpl-project/compiler/lexer.monkey<239>";
		popErr();
		return false;
	}
}
bb_token_eToken::bb_token_eToken(){
}
void bb_token_eToken::mark(){
	Object::mark();
}
int bb_stringutils_HexToInteger(String t_hex,bb_byref_BoolByRef* t_success){
	pushErr();
	errInfo="C:/harpl-project/utils/stringutils.monkey<6>";
	int t_digit=0;
	errInfo="C:/harpl-project/utils/stringutils.monkey<6>";
	int t_value=0;
	errInfo="C:/harpl-project/utils/stringutils.monkey<7>";
	for(int t_i=0;t_i<t_hex.Length();t_i=t_i+1){
		errInfo="C:/harpl-project/utils/stringutils.monkey<8>";
		t_value*=16;
		errInfo="C:/harpl-project/utils/stringutils.monkey<9>";
		int t_1=(int)t_hex[t_i];
		errInfo="C:/harpl-project/utils/stringutils.monkey<10>";
		if(t_1==48){
			errInfo="C:/harpl-project/utils/stringutils.monkey<10>";
			t_digit=0;
		}else{
			errInfo="C:/harpl-project/utils/stringutils.monkey<11>";
			if(t_1==49){
				errInfo="C:/harpl-project/utils/stringutils.monkey<11>";
				t_digit=1;
			}else{
				errInfo="C:/harpl-project/utils/stringutils.monkey<12>";
				if(t_1==50){
					errInfo="C:/harpl-project/utils/stringutils.monkey<12>";
					t_digit=2;
				}else{
					errInfo="C:/harpl-project/utils/stringutils.monkey<13>";
					if(t_1==51){
						errInfo="C:/harpl-project/utils/stringutils.monkey<13>";
						t_digit=3;
					}else{
						errInfo="C:/harpl-project/utils/stringutils.monkey<14>";
						if(t_1==52){
							errInfo="C:/harpl-project/utils/stringutils.monkey<14>";
							t_digit=4;
						}else{
							errInfo="C:/harpl-project/utils/stringutils.monkey<15>";
							if(t_1==53){
								errInfo="C:/harpl-project/utils/stringutils.monkey<15>";
								t_digit=5;
							}else{
								errInfo="C:/harpl-project/utils/stringutils.monkey<16>";
								if(t_1==54){
									errInfo="C:/harpl-project/utils/stringutils.monkey<16>";
									t_digit=6;
								}else{
									errInfo="C:/harpl-project/utils/stringutils.monkey<17>";
									if(t_1==55){
										errInfo="C:/harpl-project/utils/stringutils.monkey<17>";
										t_digit=7;
									}else{
										errInfo="C:/harpl-project/utils/stringutils.monkey<18>";
										if(t_1==56){
											errInfo="C:/harpl-project/utils/stringutils.monkey<18>";
											t_digit=8;
										}else{
											errInfo="C:/harpl-project/utils/stringutils.monkey<19>";
											if(t_1==57){
												errInfo="C:/harpl-project/utils/stringutils.monkey<19>";
												t_digit=9;
											}else{
												errInfo="C:/harpl-project/utils/stringutils.monkey<20>";
												if(t_1==65 || t_1==97){
													errInfo="C:/harpl-project/utils/stringutils.monkey<20>";
													t_digit=10;
												}else{
													errInfo="C:/harpl-project/utils/stringutils.monkey<21>";
													if(t_1==66 || t_1==98){
														errInfo="C:/harpl-project/utils/stringutils.monkey<21>";
														t_digit=11;
													}else{
														errInfo="C:/harpl-project/utils/stringutils.monkey<22>";
														if(t_1==67 || t_1==99){
															errInfo="C:/harpl-project/utils/stringutils.monkey<22>";
															t_digit=12;
														}else{
															errInfo="C:/harpl-project/utils/stringutils.monkey<23>";
															if(t_1==68 || t_1==100){
																errInfo="C:/harpl-project/utils/stringutils.monkey<23>";
																t_digit=13;
															}else{
																errInfo="C:/harpl-project/utils/stringutils.monkey<24>";
																if(t_1==69 || t_1==101){
																	errInfo="C:/harpl-project/utils/stringutils.monkey<24>";
																	t_digit=14;
																}else{
																	errInfo="C:/harpl-project/utils/stringutils.monkey<25>";
																	if(t_1==70 || t_1==102){
																		errInfo="C:/harpl-project/utils/stringutils.monkey<25>";
																		t_digit=15;
																	}else{
																		errInfo="C:/harpl-project/utils/stringutils.monkey<27>";
																		if(t_success!=0){
																			errInfo="C:/harpl-project/utils/stringutils.monkey<27>";
																			t_success->f_value=false;
																		}
																		errInfo="C:/harpl-project/utils/stringutils.monkey<28>";
																		break;
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		errInfo="C:/harpl-project/utils/stringutils.monkey<30>";
		t_value=t_value+t_digit;
	}
	errInfo="C:/harpl-project/utils/stringutils.monkey<32>";
	if(t_success!=0){
		errInfo="C:/harpl-project/utils/stringutils.monkey<32>";
		t_success->f_value=true;
	}
	errInfo="C:/harpl-project/utils/stringutils.monkey<33>";
	popErr();
	return t_value;
}
String bb_lexer_ScapeChars(String t_text){
	pushErr();
	errInfo="C:/harpl-project/compiler/lexer.monkey<244>";
	String t_=t_text.Replace(String(L"~n"),String(L"\n")).Replace(String(L"~q"),String(L"'")).Replace(String(L"~d"),String(L"\"")).Replace(String(L"~~"),String(L"~")).Replace(String(L"~t"),String(L"\t")).Replace(String(L"~r"),String(L"\r"));
	popErr();
	return t_;
}
String bb_retro_Mid(String t_value,int t_index,int t_count){
	pushErr();
	errInfo="C:/harpl-project/utils/retro.monkey<17>";
	t_index-=1;
	errInfo="C:/harpl-project/utils/retro.monkey<18>";
	String t_=t_value.Slice(t_index,t_index+t_count);
	popErr();
	return t_;
}
String bb_retro_Mid2(String t_value,int t_index){
	pushErr();
	errInfo="C:/harpl-project/utils/retro.monkey<23>";
	t_index-=1;
	errInfo="C:/harpl-project/utils/retro.monkey<24>";
	String t_=t_value.Slice(t_index);
	popErr();
	return t_;
}
bb_list_Enumerator::bb_list_Enumerator(){
	f__list=0;
	f__curr=0;
}
bb_list_Enumerator* bb_list_Enumerator::g_new(bb_list_List2* t_list){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<264>";
	gc_assign(f__list,t_list);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<265>";
	gc_assign(f__curr,t_list->f__head->f__succ);
	popErr();
	return this;
}
bb_list_Enumerator* bb_list_Enumerator::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<261>";
	popErr();
	return this;
}
bool bb_list_Enumerator::m_HasNext(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<269>";
	while(f__curr->f__succ->f__pred!=f__curr){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<270>";
		gc_assign(f__curr,f__curr->f__succ);
	}
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<272>";
	bool t_=f__curr!=f__list->f__head;
	popErr();
	return t_;
}
bb_token_Token* bb_list_Enumerator::m_NextObject(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<276>";
	bb_token_Token* t_data=f__curr->f__data;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<277>";
	gc_assign(f__curr,f__curr->f__succ);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<278>";
	popErr();
	return t_data;
}
void bb_list_Enumerator::mark(){
	Object::mark();
	gc_mark_q(f__list);
	gc_mark_q(f__curr);
}
bb_list_Enumerator2::bb_list_Enumerator2(){
	f__list=0;
	f__curr=0;
}
bb_list_Enumerator2* bb_list_Enumerator2::g_new(bb_list_List* t_list){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<264>";
	gc_assign(f__list,t_list);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<265>";
	gc_assign(f__curr,t_list->f__head->f__succ);
	popErr();
	return this;
}
bb_list_Enumerator2* bb_list_Enumerator2::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<261>";
	popErr();
	return this;
}
bool bb_list_Enumerator2::m_HasNext(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<269>";
	while(f__curr->f__succ->f__pred!=f__curr){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<270>";
		gc_assign(f__curr,f__curr->f__succ);
	}
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<272>";
	bool t_=f__curr!=f__list->f__head;
	popErr();
	return t_;
}
bb_compiler_CompileError* bb_list_Enumerator2::m_NextObject(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<276>";
	bb_compiler_CompileError* t_data=f__curr->f__data;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<277>";
	gc_assign(f__curr,f__curr->f__succ);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<278>";
	popErr();
	return t_data;
}
void bb_list_Enumerator2::mark(){
	Object::mark();
	gc_mark_q(f__list);
	gc_mark_q(f__curr);
}
int bbMain(){
	pushErr();
	errInfo="C:/harpl-project/Harpl.monkey<27>";
	Print(String(L"======================================================"));
	errInfo="C:/harpl-project/Harpl.monkey<28>";
	Print(bb_Harpl_AppString());
	errInfo="C:/harpl-project/Harpl.monkey<29>";
	Print(String(L"======================================================"));
	errInfo="C:/harpl-project/Harpl.monkey<30>";
	if(AppArgs().Length()<2){
		errInfo="C:/harpl-project/Harpl.monkey<31>";
		bb_Harpl_ShowCommandLineArgs();
		errInfo="C:/harpl-project/Harpl.monkey<32>";
		bb_Harpl_AbortExecution(String(L"No command-line parameters were found."),0);
	}else{
		errInfo="C:/harpl-project/Harpl.monkey<33>";
		if(AppArgs().Length()>2){
			errInfo="C:/harpl-project/Harpl.monkey<34>";
			bb_Harpl_ShowCommandLineArgs();
			errInfo="C:/harpl-project/Harpl.monkey<35>";
			bb_Harpl_AbortExecution(String(L"Too many parameters."),-1);
		}
	}
	errInfo="C:/harpl-project/Harpl.monkey<38>";
	bb_compiler_Compiler* t_localCompiler=(new bb_compiler_Compiler)->g_new();
	errInfo="C:/harpl-project/Harpl.monkey<39>";
	if(t_localCompiler->m_CompileFile(AppArgs().At(1))==false){
		errInfo="C:/harpl-project/Harpl.monkey<40>";
		errInfo="C:/harpl-project/Harpl.monkey<40>";
		bb_list_Enumerator2* t_=t_localCompiler->f_compileErrors->m_ObjectEnumerator();
		errInfo="C:/harpl-project/Harpl.monkey<40>";
		while(t_->m_HasNext()){
			errInfo="C:/harpl-project/Harpl.monkey<40>";
			bb_compiler_CompileError* t_err=t_->m_NextObject();
			errInfo="C:/harpl-project/Harpl.monkey<41>";
			Print(String(L"Error: ")+t_err->f_description);
			errInfo="C:/harpl-project/Harpl.monkey<42>";
			if(t_err->f_file!=String()){
				errInfo="C:/harpl-project/Harpl.monkey<43>";
				Print(String(L"    At file: ")+t_err->f_file+String(L"[")+String(t_err->f_posX)+String(L",")+String(t_err->f_posY)+String(L"]"));
			}
			errInfo="C:/harpl-project/Harpl.monkey<45>";
			Print(String());
		}
	}
	popErr();
	return 0;
}
bb_reflection_FieldInfo::bb_reflection_FieldInfo(){
	f__name=String();
	f__attrs=0;
	f__type=0;
}
bb_reflection_FieldInfo* bb_reflection_FieldInfo::g_new(String t_name,int t_attrs,bb_reflection_ClassInfo* t_type){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<153>";
	f__name=t_name;
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<154>";
	f__attrs=t_attrs;
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<155>";
	gc_assign(f__type,t_type);
	popErr();
	return this;
}
bb_reflection_FieldInfo* bb_reflection_FieldInfo::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<150>";
	popErr();
	return this;
}
void bb_reflection_FieldInfo::mark(){
	Object::mark();
	gc_mark_q(f__type);
}
bb_reflection_R3::bb_reflection_R3(){
}
bb_reflection_R3* bb_reflection_R3::g_new(){
	bb_reflection_FieldInfo::g_new(String(L"value"),0,bb_reflection__boolClass);
	return this;
}
void bb_reflection_R3::mark(){
	bb_reflection_FieldInfo::mark();
}
bb_reflection_MethodInfo::bb_reflection_MethodInfo(){
	f__name=String();
	f__attrs=0;
	f__retType=0;
	f__argTypes=Array<bb_reflection_ClassInfo* >();
}
bb_reflection_MethodInfo* bb_reflection_MethodInfo::g_new(String t_name,int t_attrs,bb_reflection_ClassInfo* t_retType,Array<bb_reflection_ClassInfo* > t_argTypes){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<185>";
	f__name=t_name;
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<186>";
	f__attrs=t_attrs;
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<187>";
	gc_assign(f__retType,t_retType);
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<188>";
	gc_assign(f__argTypes,t_argTypes);
	popErr();
	return this;
}
bb_reflection_MethodInfo* bb_reflection_MethodInfo::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<182>";
	popErr();
	return this;
}
void bb_reflection_MethodInfo::mark(){
	Object::mark();
	gc_mark_q(f__retType);
	gc_mark_q(f__argTypes);
}
bb_reflection_R5::bb_reflection_R5(){
}
bb_reflection_R5* bb_reflection_R5::g_new(){
	bb_reflection_MethodInfo::g_new(String(L"ToBool"),0,bb_reflection__boolClass,Array<bb_reflection_ClassInfo* >());
	return this;
}
void bb_reflection_R5::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R6::bb_reflection_R6(){
}
bb_reflection_R6* bb_reflection_R6::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__classes.At(0)};
	bb_reflection_MethodInfo::g_new(String(L"Equals"),0,bb_reflection__boolClass,Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R6::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_FunctionInfo::bb_reflection_FunctionInfo(){
	f__name=String();
	f__attrs=0;
	f__retType=0;
	f__argTypes=Array<bb_reflection_ClassInfo* >();
}
bb_reflection_FunctionInfo* bb_reflection_FunctionInfo::g_new(String t_name,int t_attrs,bb_reflection_ClassInfo* t_retType,Array<bb_reflection_ClassInfo* > t_argTypes){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<221>";
	f__name=t_name;
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<222>";
	f__attrs=t_attrs;
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<223>";
	gc_assign(f__retType,t_retType);
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<224>";
	gc_assign(f__argTypes,t_argTypes);
	popErr();
	return this;
}
bb_reflection_FunctionInfo* bb_reflection_FunctionInfo::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/reflection/reflection.monkey<218>";
	popErr();
	return this;
}
void bb_reflection_FunctionInfo::mark(){
	Object::mark();
	gc_mark_q(f__retType);
	gc_mark_q(f__argTypes);
}
bb_reflection_R4::bb_reflection_R4(){
}
bb_reflection_R4* bb_reflection_R4::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__boolClass};
	bb_reflection_FunctionInfo::g_new(String(L"monkey.boxes.BoolObject.new"),0,bb_reflection__classes.At(0),Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R4::mark(){
	bb_reflection_FunctionInfo::mark();
}
bb_reflection_R7::bb_reflection_R7(){
}
bb_reflection_R7* bb_reflection_R7::g_new(){
	bb_reflection_FunctionInfo::g_new(String(L"monkey.boxes.BoolObject.new"),0,bb_reflection__classes.At(0),Array<bb_reflection_ClassInfo* >());
	return this;
}
void bb_reflection_R7::mark(){
	bb_reflection_FunctionInfo::mark();
}
bb_reflection_R9::bb_reflection_R9(){
}
bb_reflection_R9* bb_reflection_R9::g_new(){
	bb_reflection_FieldInfo::g_new(String(L"value"),0,bb_reflection__intClass);
	return this;
}
void bb_reflection_R9::mark(){
	bb_reflection_FieldInfo::mark();
}
bb_reflection_R12::bb_reflection_R12(){
}
bb_reflection_R12* bb_reflection_R12::g_new(){
	bb_reflection_MethodInfo::g_new(String(L"ToInt"),0,bb_reflection__intClass,Array<bb_reflection_ClassInfo* >());
	return this;
}
void bb_reflection_R12::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R13::bb_reflection_R13(){
}
bb_reflection_R13* bb_reflection_R13::g_new(){
	bb_reflection_MethodInfo::g_new(String(L"ToFloat"),0,bb_reflection__floatClass,Array<bb_reflection_ClassInfo* >());
	return this;
}
void bb_reflection_R13::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R14::bb_reflection_R14(){
}
bb_reflection_R14* bb_reflection_R14::g_new(){
	bb_reflection_MethodInfo::g_new(String(L"ToString"),0,bb_reflection__stringClass,Array<bb_reflection_ClassInfo* >());
	return this;
}
void bb_reflection_R14::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R15::bb_reflection_R15(){
}
bb_reflection_R15* bb_reflection_R15::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__classes.At(1)};
	bb_reflection_MethodInfo::g_new(String(L"Equals"),0,bb_reflection__boolClass,Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R15::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R16::bb_reflection_R16(){
}
bb_reflection_R16* bb_reflection_R16::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__classes.At(1)};
	bb_reflection_MethodInfo::g_new(String(L"Compare"),0,bb_reflection__intClass,Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R16::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R10::bb_reflection_R10(){
}
bb_reflection_R10* bb_reflection_R10::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__intClass};
	bb_reflection_FunctionInfo::g_new(String(L"monkey.boxes.IntObject.new"),0,bb_reflection__classes.At(1),Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R10::mark(){
	bb_reflection_FunctionInfo::mark();
}
bb_reflection_R11::bb_reflection_R11(){
}
bb_reflection_R11* bb_reflection_R11::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__floatClass};
	bb_reflection_FunctionInfo::g_new(String(L"monkey.boxes.IntObject.new"),0,bb_reflection__classes.At(1),Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R11::mark(){
	bb_reflection_FunctionInfo::mark();
}
bb_reflection_R17::bb_reflection_R17(){
}
bb_reflection_R17* bb_reflection_R17::g_new(){
	bb_reflection_FunctionInfo::g_new(String(L"monkey.boxes.IntObject.new"),0,bb_reflection__classes.At(1),Array<bb_reflection_ClassInfo* >());
	return this;
}
void bb_reflection_R17::mark(){
	bb_reflection_FunctionInfo::mark();
}
bb_reflection_R19::bb_reflection_R19(){
}
bb_reflection_R19* bb_reflection_R19::g_new(){
	bb_reflection_FieldInfo::g_new(String(L"value"),0,bb_reflection__floatClass);
	return this;
}
void bb_reflection_R19::mark(){
	bb_reflection_FieldInfo::mark();
}
bb_reflection_R22::bb_reflection_R22(){
}
bb_reflection_R22* bb_reflection_R22::g_new(){
	bb_reflection_MethodInfo::g_new(String(L"ToInt"),0,bb_reflection__intClass,Array<bb_reflection_ClassInfo* >());
	return this;
}
void bb_reflection_R22::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R23::bb_reflection_R23(){
}
bb_reflection_R23* bb_reflection_R23::g_new(){
	bb_reflection_MethodInfo::g_new(String(L"ToFloat"),0,bb_reflection__floatClass,Array<bb_reflection_ClassInfo* >());
	return this;
}
void bb_reflection_R23::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R24::bb_reflection_R24(){
}
bb_reflection_R24* bb_reflection_R24::g_new(){
	bb_reflection_MethodInfo::g_new(String(L"ToString"),0,bb_reflection__stringClass,Array<bb_reflection_ClassInfo* >());
	return this;
}
void bb_reflection_R24::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R25::bb_reflection_R25(){
}
bb_reflection_R25* bb_reflection_R25::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__classes.At(2)};
	bb_reflection_MethodInfo::g_new(String(L"Equals"),0,bb_reflection__boolClass,Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R25::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R26::bb_reflection_R26(){
}
bb_reflection_R26* bb_reflection_R26::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__classes.At(2)};
	bb_reflection_MethodInfo::g_new(String(L"Compare"),0,bb_reflection__intClass,Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R26::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R20::bb_reflection_R20(){
}
bb_reflection_R20* bb_reflection_R20::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__intClass};
	bb_reflection_FunctionInfo::g_new(String(L"monkey.boxes.FloatObject.new"),0,bb_reflection__classes.At(2),Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R20::mark(){
	bb_reflection_FunctionInfo::mark();
}
bb_reflection_R21::bb_reflection_R21(){
}
bb_reflection_R21* bb_reflection_R21::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__floatClass};
	bb_reflection_FunctionInfo::g_new(String(L"monkey.boxes.FloatObject.new"),0,bb_reflection__classes.At(2),Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R21::mark(){
	bb_reflection_FunctionInfo::mark();
}
bb_reflection_R27::bb_reflection_R27(){
}
bb_reflection_R27* bb_reflection_R27::g_new(){
	bb_reflection_FunctionInfo::g_new(String(L"monkey.boxes.FloatObject.new"),0,bb_reflection__classes.At(2),Array<bb_reflection_ClassInfo* >());
	return this;
}
void bb_reflection_R27::mark(){
	bb_reflection_FunctionInfo::mark();
}
bb_reflection_R29::bb_reflection_R29(){
}
bb_reflection_R29* bb_reflection_R29::g_new(){
	bb_reflection_FieldInfo::g_new(String(L"value"),0,bb_reflection__stringClass);
	return this;
}
void bb_reflection_R29::mark(){
	bb_reflection_FieldInfo::mark();
}
bb_reflection_R33::bb_reflection_R33(){
}
bb_reflection_R33* bb_reflection_R33::g_new(){
	bb_reflection_MethodInfo::g_new(String(L"ToString"),0,bb_reflection__stringClass,Array<bb_reflection_ClassInfo* >());
	return this;
}
void bb_reflection_R33::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R34::bb_reflection_R34(){
}
bb_reflection_R34* bb_reflection_R34::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__classes.At(3)};
	bb_reflection_MethodInfo::g_new(String(L"Equals"),0,bb_reflection__boolClass,Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R34::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R35::bb_reflection_R35(){
}
bb_reflection_R35* bb_reflection_R35::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__classes.At(3)};
	bb_reflection_MethodInfo::g_new(String(L"Compare"),0,bb_reflection__intClass,Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R35::mark(){
	bb_reflection_MethodInfo::mark();
}
bb_reflection_R30::bb_reflection_R30(){
}
bb_reflection_R30* bb_reflection_R30::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__intClass};
	bb_reflection_FunctionInfo::g_new(String(L"monkey.boxes.StringObject.new"),0,bb_reflection__classes.At(3),Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R30::mark(){
	bb_reflection_FunctionInfo::mark();
}
bb_reflection_R31::bb_reflection_R31(){
}
bb_reflection_R31* bb_reflection_R31::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__floatClass};
	bb_reflection_FunctionInfo::g_new(String(L"monkey.boxes.StringObject.new"),0,bb_reflection__classes.At(3),Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R31::mark(){
	bb_reflection_FunctionInfo::mark();
}
bb_reflection_R32::bb_reflection_R32(){
}
bb_reflection_R32* bb_reflection_R32::g_new(){
	bb_reflection_ClassInfo* t_[]={bb_reflection__stringClass};
	bb_reflection_FunctionInfo::g_new(String(L"monkey.boxes.StringObject.new"),0,bb_reflection__classes.At(3),Array<bb_reflection_ClassInfo* >(t_,1));
	return this;
}
void bb_reflection_R32::mark(){
	bb_reflection_FunctionInfo::mark();
}
bb_reflection_R36::bb_reflection_R36(){
}
bb_reflection_R36* bb_reflection_R36::g_new(){
	bb_reflection_FunctionInfo::g_new(String(L"monkey.boxes.StringObject.new"),0,bb_reflection__classes.At(3),Array<bb_reflection_ClassInfo* >());
	return this;
}
void bb_reflection_R36::mark(){
	bb_reflection_FunctionInfo::mark();
}
int bbInit(){
	bb_reflection__classes=Array<bb_reflection_ClassInfo* >();
	bb_reflection__unknownClass=((new bb_reflection_UnknownClass)->g_new());
	bb_reflection__boolClass=0;
	bb_reflection__intClass=0;
	bb_reflection__floatClass=0;
	bb_reflection__stringClass=0;
	bb_reflection__getClass=0;
	bb_reflection__init=bb_reflection___init();
	return 0;
}
void gc_mark(){
	gc_mark_q(bb_reflection__classes);
	gc_mark_q(bb_reflection__unknownClass);
	gc_mark_q(bb_reflection__boolClass);
	gc_mark_q(bb_reflection__intClass);
	gc_mark_q(bb_reflection__floatClass);
	gc_mark_q(bb_reflection__stringClass);
	gc_mark_q(bb_reflection__getClass);
}
//${TRANSCODE_END}

int main( int argc,const char **argv ){

	try{
	
		bb_std_main( argc,argv );
		
	}catch( const char *err ){
	
		Print( String("Monkey runtime error: ")+err+"\n"+StackTrace() );
	}
}
