
#include "main.h"

//${CONFIG_BEGIN}
#define CFG_CONFIG debug
#define CFG_CPP_DOUBLE_PRECISION_FLOATS 1
#define CFG_CPP_INCREMENTAL_GC 1
#define CFG_DEBUG 1
#define CFG_HOST winnt
#define CFG_LANG cpp
#define CFG_PARSER_FUNC_ATTRS 0
#define CFG_TARGET stdcpp
//${CONFIG_END}

//${TRANSCODE_BEGIN}

// C++ Monkey runtime.
//
// Placed into the public domain 24/02/2011.
// No warranty implied; use at your own risk.

/*
#include <cmath>
#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <typeinfo>
#include <signal.h>
#if _WIN32
#include <windows.h>
#endif
*/

#if CFG_CPP_DOUBLE_PRECISION_FLOATS
typedef double Float;
#define FLOAT(X) X
#else
typedef float Float;
#define FLOAT(X) X##f
#endif

//***** GC Config *****

//#define CFG_CPP_DEBUG_GC 1

#if CFG_CPP_DEBUG_GC
#if __APPLE__
#define DEBUG_GC_MAC 1
#elif defined( __glfw_h_ )
#define DEBUG_GC_GLFW 1
#else
#undef DEBUG_GC
#endif
#endif

//***** Simple profiler *****

#if PROFILE

#include <mmsystem.h>
#include <map>
#include <algorithm>

DWORD profTimer;
CRITICAL_SECTION profLock;
std::vector<const char*> profStack;
std::map<const char*,int> profTicksLocal;
std::map<const char*,int> profTicksTotal;

void profEnter( const char *p ){
	EnterCriticalSection( &profLock );
	profStack.push_back( p );
	LeaveCriticalSection( &profLock );
}

void profLeave(){
	EnterCriticalSection( &profLock );
	profStack.pop_back();
	LeaveCriticalSection( &profLock );
}

void CALLBACK profTimerTick( UINT uTimerID,UINT uMsg,DWORD dwUser,DWORD dw1,DWORD dw2 ){
	EnterCriticalSection( &profLock );
	if( profStack.size() ){
		++profTicksLocal[profStack.back()];
		for( int i=0;i<profStack.size();++i ){
			++profTicksTotal[ profStack[i] ];
		}
	}
	LeaveCriticalSection( &profLock );
}

void profStart(){
	InitializeCriticalSection( &profLock );
	profTimer=timeSetEvent( 5,0,profTimerTick,0,TIME_PERIODIC|TIME_CALLBACK_FUNCTION );//	|TIME_KILL_SYNCHRONOUS );
}

struct ProfInfo{
	int n;
	const char *p;
	ProfInfo( int n,const char *p ):n(n),p(p){
	}
	bool operator<( const ProfInfo &i )const{
		return n>i.n;
	}
};

void profDump( const std::map<const char*,int> &ticks ){
	std::vector<ProfInfo> infos;
	int sum=0;
	for( std::map<const char*,int>::const_iterator it=ticks.begin();it!=ticks.end();++it ){
		const char *p=(*it).first;
		int n=(*it).second;
		sum+=n;
		infos.push_back( ProfInfo( n,p ) );
	}
	std::sort( infos.begin(),infos.end() );
	for( int i=0;i<infos.size();++i ){
		int t=infos[i].n*10000/sum;
		printf( "%i.%i%% : %s\n",t/100,t%100,infos[i].p );
	}
}

void profStop(){
	timeKillEvent( profTimer );

	EnterCriticalSection( &profLock );

	printf( "\nLocal:\n" );
	profDump( profTicksLocal );

	printf( "\nTotal:\n" );
	profDump( profTicksTotal );

	fflush( stdout );

	LeaveCriticalSection( &profLock );
}

#define P_START profStart();
#define P_STOP profStop();
#define P_ENTER(X) profEnter( X );
#define P_LEAVE profLeave();

#else

#define P_START
#define P_STOP
#define P_ENTER(X)
#define P_LEAVE

#endif

// ***** GC *****

#if DEBUG_GC_MAC
#include <mach/mach_time.h>
int gcMicros(){
	static uint64_t startTime;
	static mach_timebase_info_data_t timeInfo;
	if( !startTime ){
		startTime=mach_absolute_time();
		mach_timebase_info( &timeInfo );
	}
	uint64_t nanos=mach_absolute_time()-startTime;
	nanos*=timeInfo.numer;
	nanos/=timeInfo.denom;
	return nanos/1000L;
}
#endif

#if DEBUG_GC_GLFW
int gcMicros(){
	return glfwGetTime()*1000000;
}
#endif

struct gc_object;

gc_object *gc_malloc( int size );
void gc_free( gc_object *p );

struct gc_object{
	gc_object *succ;
	int flags;
	
	virtual ~gc_object(){
	}
	
	virtual void mark(){
	}
	
	void *operator new( size_t size ){
		return gc_malloc( size );
	}
	
	void operator delete( void *p ){
		gc_free( (gc_object*)p );
	}
};

//alloced objs
gc_object *gc_objs;

//fast alloc cache
gc_object *gc_cache[8];

//objects allocated
int gc_total;

//objects marked
int gc_marked;

//toggling markbit
int gc_markbit;

//how much mem alloced
int gc_alloced;
int gc_maxalloced;

//queue of objects to mark
std::vector<gc_object*> gc_mark_queue;

//generated by translator
void gc_mark();
#define gc_mark_roots gc_mark

//void gc_mark_roots();

gc_object *gc_malloc( int size ){
	size=(size+7)&~7;
	
	gc_object *p;
	if( size<64 ){
		if( (p=gc_cache[size>>3]) ){
			gc_cache[size>>3]=p->succ;
		}else{
			p=(gc_object*)malloc( size );
		}
	}else{
		p=(gc_object*)malloc( size );
	}
	
	p->flags=size | (gc_markbit^1);
	p->succ=gc_objs;
	gc_objs=p;

	++gc_total;
	
	gc_alloced+=size;
	if( gc_alloced>gc_maxalloced ) gc_maxalloced=gc_alloced;
	
	return p;
}

void gc_free( gc_object *p ){
	int size=p->flags & ~7;
	if( size<64 ){
		p->succ=gc_cache[size>>3];
		gc_cache[size>>3]=p;
	}else{
		free( p );
	}
	--gc_total;
	gc_alloced-=size;
}

inline void gc_mark( gc_object *p ){
	if( !p || (p->flags & 1)==gc_markbit ) return;
	p->flags^=1;
	++gc_marked;
	p->mark();
}

inline void gc_mark_q( gc_object *p ){
	if( !p || (p->flags & 1)==gc_markbit ) return;
	p->flags^=1;
	++gc_marked;
	gc_mark_queue.push_back( p );
}

#if CFG_CPP_INCREMENTAL_GC

template<class T,class V> void gc_assign( T *&lhs,V *rhs ){
	//
	//Ok, the dynamic_cast should be 'free' if rhs is an object, not an interface, as it's a simple upcast.
	//
	//So far, this seems to be true of both msvc and llvm.
	//
	//This could be used with gc_mark and gc_mark_q, allowing gc_iptr to be nuked - yay! Later...
	//
	gc_mark_q( dynamic_cast<gc_object*>( rhs ) );
	lhs=rhs;
}

void gc_collect(){

#if DEBUG_GC
	int us=gcMicros();
#endif

	int swept=0;
	
	static int maxalloced;

	int c=0;
	
	if( gc_maxalloced>maxalloced ){
		maxalloced=gc_maxalloced;
		c=gc_total;
	}else{
		c=gc_total/10;
	}
	
	int term=gc_marked+c;
	
	while( gc_marked<term ){
	
		if( gc_mark_queue.empty() ){
		
			//sweep!
			
			gc_object **q=&gc_objs;
			
			swept=gc_total;
			
			while( gc_marked!=gc_total ){
				gc_object *p=*q;
				
				while( (p->flags & 1)==gc_markbit ){
					q=&p->succ;
					p=*q;
				}

				*q=p->succ;
				
				delete p;
			}
			
			swept-=gc_total;
			
			gc_markbit^=1;
			gc_marked=0;
			
			gc_mark_roots();
			
			break;
		}
		
		gc_object *p=gc_mark_queue.back();
		gc_mark_queue.pop_back();
		p->mark();
	}

#if DEBUG_GC
	us=gcMicros()-us;
	printf( "us=%i, swept=%i, objects=%i, memalloced=%i, maxalloced=%i\n",us,swept,gc_total,gc_alloced,gc_maxalloced );fflush( stdout );
#endif
}

#else

#define gc_assign( X,Y ) X=Y

void gc_collect(){

#if DEBUG_GC
	int us=gcMicros();
#endif
	
	//mark...

	gc_mark_roots();
	
	while( !gc_mark_queue.empty() ){
		gc_object *p=gc_mark_queue.back();
		gc_mark_queue.pop_back();
		p->mark();
	}
	
	//sweep...
	
	gc_object **q=&gc_objs;
	
	int swept=gc_total;

	while( gc_marked!=gc_total ){
		gc_object *p=*q;
		
		while( (p->flags & 1)==gc_markbit ){
			q=&p->succ;
			p=*q;
		}
		
		*q=p->succ;
		delete p;
	}
	
	swept-=gc_total;

	gc_markbit^=1;
	gc_marked=0;
	
#if DEBUG_GC
	us=gcMicros()-us;
	printf( "us=%i, swept=%i, objects=%i, memalloced=%i, maxalloced=%i\n",us,swept,gc_total,gc_alloced,gc_maxalloced );fflush( stdout );
#endif
}

#endif

// ***** Monkey Types *****

typedef wchar_t Char;
template<class T> class Array;
class String;
class Object;

// ***** Array *****

template<class T> T *t_memcpy( T *dst,const T *src,int n ){
	memcpy( dst,src,n*sizeof(T) );
	return dst+n;
}

template<class T> T *t_memset( T *dst,int val,int n ){
	memset( dst,val,n*sizeof(T) );
	return dst+n;
}

template<class T> int t_memcmp( const T *x,const T *y,int n ){
	return memcmp( x,y,n*sizeof(T) );
}

template<class T> int t_strlen( const T *p ){
	const T *q=p++;
	while( *q++ ){}
	return q-p;
}

template<class T> T *t_create( int n,T *p ){
	t_memset( p,0,n );
	return p+n;
}

template<class T> T *t_create( int n,T *p,const T *q ){
	t_memcpy( p,q,n );
	return p+n;
}

template<class T> void t_destroy( int n,T *p ){
}

//for int, float etc arrays...needs to go before Array<> decl to shut xcode 4.0.2 up.
template<class T> void gc_mark_array( int n,T *p ){
}

template<class T> class Array{
public:
	Array():rep( Rep::alloc(0) ){
	}

	//Use default...
//	Array( const Array<T> &t )...
	
	Array( int length ):rep( Rep::alloc( length ) ){
		t_create( rep->length,rep->data );
	}
	
	Array( const T *p,int length ):rep( Rep::alloc(length) ){
		t_create( rep->length,rep->data,p );
	}
	
	~Array(){
	}

	//Use default...
//	Array &operator=( const Array &t )...
	
	int Length()const{ 
		return rep->length; 
	}
	
	T &At( int index ){
		if( index<0 || index>=rep->length ) throw "Array index out of range";
		return rep->data[index]; 
	}
	
	const T &At( int index )const{
		if( index<0 || index>=rep->length ) throw "Array index out of range";
		return rep->data[index]; 
	}
	
	T &operator[]( int index ){ 
		return rep->data[index]; 
	}

	const T &operator[]( int index )const{
		return rep->data[index]; 
	}
	
	Array Slice( int from,int term )const{
		int len=rep->length;
		if( from<0 ){ 
			from+=len;
			if( from<0 ) from=0;
		}else if( from>len ){
			from=len;
		}
		if( term<0 ){
			term+=len;
		}else if( term>len ){
			term=len;
		}
		if( term<=from ) return Array();
		return Array( rep->data+from,term-from );
	}

	Array Slice( int from )const{
		return Slice( from,rep->length );
	}
	
	Array Resize( int newlen )const{
		if( newlen<=0 ) return Array();
		int n=rep->length;
		if( newlen<n ) n=newlen;
		Rep *p=Rep::alloc( newlen );
		T *q=p->data;
		q=t_create( n,q,rep->data );
		q=t_create( (newlen-n),q );
		return Array( p );
	}

private:
	struct Rep : public gc_object{
		int length;
		T data[0];
		
		Rep( int length ):length(length){
		}
		
		~Rep(){
			t_destroy( length,data );
		}
		
		void mark(){
			gc_mark_array( length,data );
		}
		
		static Rep *alloc( int length ){
			void *p=gc_malloc( sizeof(Rep)+length*sizeof(T) );
			return ::new(p) Rep( length );
		}
	};
	Rep *rep;

	template<class C> friend void gc_mark( Array<C> &t );
	template<class C> friend void gc_mark_q( Array<C> &t );

#if CFG_CPP_INCREMENTAL_GC

	template<class C> friend void gc_assign( Array<C> &lhs,Array<C> rhs );
	
#endif

	Array( Rep *rep ):rep(rep){
	}
};

template<class T> void gc_mark( Array<T> &t ){
	gc_mark( t.rep );
}

template<class T> void gc_mark_q( Array<T> &t ){
	gc_mark_q( t.rep );
}

//for object arrays....
template<class T> void gc_mark_array( int n,T **p ){
	for( int i=0;i<n;++i ) gc_mark( p[i] );
}

//for array arrays...
template<class T> void gc_mark_array( int n,Array<T> *p ){
	for( int i=0;i<n;++i ) gc_mark( p[i] );
}

#if CFG_CPP_INCREMENTAL_GC

template<class T> void gc_assign( Array<T> &lhs,Array<T> rhs ){
	gc_mark_q( rhs.rep );
	lhs=rhs;
}

#endif
		
// ***** String *****

class String{
public:
	String():rep( Rep::alloc(0) ){
	}
	
	String( const String &t ):rep( t.rep ){
		rep->retain();
	}

	String( int n ){
		char buf[256];
		sprintf( buf,"%i",n );
		rep=Rep::alloc( t_strlen(buf) );
		for( int i=0;i<rep->length;++i ) rep->data[i]=buf[i];
	}

	String( Float n ){
		char buf[256];
		
		//would rather use snprintf, but it's doing weird things in MingW.
		//
		sprintf( buf,"%.17lg",n );
		//
		char *p;
		for( p=buf;*p;++p ){
			if( *p=='.' || *p=='e' ) break;
		}
		if( !*p ){
			*p++='.';
			*p++='0';
			*p=0;
		}

		rep=Rep::alloc( t_strlen(buf) );
		for( int i=0;i<rep->length;++i ) rep->data[i]=buf[i];
	}

	String( Char ch,int length ):rep( Rep::alloc(length) ){
		for( int i=0;i<length;++i ) rep->data[i]=ch;
	}

	String( const Char *p ):rep( Rep::alloc(t_strlen(p)) ){
		t_memcpy( rep->data,p,rep->length );
	}

	String( const Char *p,int length ):rep( Rep::alloc(length) ){
		t_memcpy( rep->data,p,rep->length );
	}
	
#if __OBJC__	
	String( NSString *nsstr ):rep( Rep::alloc([nsstr length]) ){
		unichar *buf=(unichar*)malloc( rep->length * sizeof(unichar) );
		[nsstr getCharacters:buf range:NSMakeRange(0,rep->length)];
		for( int i=0;i<rep->length;++i ) rep->data[i]=buf[i];
		free( buf );
	}
#endif

	~String(){
		rep->release();
	}
	
	template<class C> String( const C *p ):rep( Rep::alloc(t_strlen(p)) ){
		for( int i=0;i<rep->length;++i ) rep->data[i]=p[i];
	}
	
	template<class C> String( const C *p,int length ):rep( Rep::alloc(length) ){
		for( int i=0;i<rep->length;++i ) rep->data[i]=p[i];
	}
	
	int Length()const{
		return rep->length;
	}
	
	const Char *Data()const{
		return rep->data;
	}
	
	Char operator[]( int index )const{
		return rep->data[index];
	}
	
	String &operator=( const String &t ){
		t.rep->retain();
		rep->release();
		rep=t.rep;
		return *this;
	}
	
	String &operator+=( const String &t ){
		return operator=( *this+t );
	}
	
	int Compare( const String &t )const{
		int n=rep->length<t.rep->length ? rep->length : t.rep->length;
		for( int i=0;i<n;++i ){
			if( int q=(int)(rep->data[i])-(int)(t.rep->data[i]) ) return q;
		}
		return rep->length-t.rep->length;
	}
	
	bool operator==( const String &t )const{
		return rep->length==t.rep->length && t_memcmp( rep->data,t.rep->data,rep->length )==0;
	}
	
	bool operator!=( const String &t )const{
		return rep->length!=t.rep->length || t_memcmp( rep->data,t.rep->data,rep->length )!=0;
	}
	
	bool operator<( const String &t )const{
		return Compare( t )<0;
	}
	
	bool operator<=( const String &t )const{
		return Compare( t )<=0;
	}
	
	bool operator>( const String &t )const{
		return Compare( t )>0;
	}
	
	bool operator>=( const String &t )const{
		return Compare( t )>=0;
	}
	
	String operator+( const String &t )const{
		if( !rep->length ) return t;
		if( !t.rep->length ) return *this;
		Rep *p=Rep::alloc( rep->length+t.rep->length );
		Char *q=p->data;
		q=t_memcpy( q,rep->data,rep->length );
		q=t_memcpy( q,t.rep->data,t.rep->length );
		return String( p );
	}
	
	int Find( String find,int start=0 )const{
		if( start<0 ) start=0;
		while( start+find.rep->length<=rep->length ){
			if( !t_memcmp( rep->data+start,find.rep->data,find.rep->length ) ) return start;
			++start;
		}
		return -1;
	}
	
	int FindLast( String find )const{
		int start=rep->length-find.rep->length;
		while( start>=0 ){
			if( !t_memcmp( rep->data+start,find.rep->data,find.rep->length ) ) return start;
			--start;
		}
		return -1;
	}
	
	int FindLast( String find,int start )const{
		if( start>rep->length-find.rep->length ) start=rep->length-find.rep->length;
		while( start>=0 ){
			if( !t_memcmp( rep->data+start,find.rep->data,find.rep->length ) ) return start;
			--start;
		}
		return -1;
	}
	
	String Trim()const{
		int i=0,i2=rep->length;
		while( i<i2 && rep->data[i]<=32 ) ++i;
		while( i2>i && rep->data[i2-1]<=32 ) --i2;
		if( i==0 && i2==rep->length ) return *this;
		return String( rep->data+i,i2-i );
	}

	Array<String> Split( String sep )const{
	
		if( !sep.rep->length ){
			Array<String> bits( rep->length );
			for( int i=0;i<rep->length;++i ){
				bits[i]=String( (Char)(*this)[i],1 );
			}
			return bits;
		}
		
		int i=0,i2,n=1;
		while( (i2=Find( sep,i ))!=-1 ){
			++n;
			i=i2+sep.rep->length;
		}
		Array<String> bits( n );
		if( n==1 ){
			bits[0]=*this;
			return bits;
		}
		i=0;n=0;
		while( (i2=Find( sep,i ))!=-1 ){
			bits[n++]=Slice( i,i2 );
			i=i2+sep.rep->length;
		}
		bits[n]=Slice( i );
		return bits;
	}

	String Join( Array<String> bits )const{
		if( bits.Length()==0 ) return String();
		if( bits.Length()==1 ) return bits[0];
		int newlen=rep->length * (bits.Length()-1);
		for( int i=0;i<bits.Length();++i ){
			newlen+=bits[i].rep->length;
		}
		Rep *p=Rep::alloc( newlen );
		Char *q=p->data;
		q=t_memcpy( q,bits[0].rep->data,bits[0].rep->length );
		for( int i=1;i<bits.Length();++i ){
			q=t_memcpy( q,rep->data,rep->length );
			q=t_memcpy( q,bits[i].rep->data,bits[i].rep->length );
		}
		return String( p );
	}

	String Replace( String find,String repl )const{
		int i=0,i2,newlen=0;
		while( (i2=Find( find,i ))!=-1 ){
			newlen+=(i2-i)+repl.rep->length;
			i=i2+find.rep->length;
		}
		if( !i ) return *this;
		newlen+=rep->length-i;
		Rep *p=Rep::alloc( newlen );
		Char *q=p->data;
		i=0;
		while( (i2=Find( find,i ))!=-1 ){
			q=t_memcpy( q,rep->data+i,i2-i );
			q=t_memcpy( q,repl.rep->data,repl.rep->length );
			i=i2+find.rep->length;
		}
		q=t_memcpy( q,rep->data+i,rep->length-i );
		return String( p );
	}

	String ToLower()const{
		for( int i=0;i<rep->length;++i ){
			Char t=tolower( rep->data[i] );
			if( t==rep->data[i] ) continue;
			Rep *p=Rep::alloc( rep->length );
			Char *q=p->data;
			t_memcpy( q,rep->data,i );
			for( q[i++]=t;i<rep->length;++i ){
				q[i]=tolower( rep->data[i] );
			}
			return String( p );
		}
		return *this;
	}

	String ToUpper()const{
		for( int i=0;i<rep->length;++i ){
			Char t=toupper( rep->data[i] );
			if( t==rep->data[i] ) continue;
			Rep *p=Rep::alloc( rep->length );
			Char *q=p->data;
			t_memcpy( q,rep->data,i );
			for( q[i++]=t;i<rep->length;++i ){
				q[i]=toupper( rep->data[i] );
			}
			return String( p );
		}
		return *this;
	}
	
	bool Contains( String sub )const{
		return Find( sub )!=-1;
	}

	bool StartsWith( String sub )const{
		return sub.rep->length<=rep->length && !t_memcmp( rep->data,sub.rep->data,sub.rep->length );
	}

	bool EndsWith( String sub )const{
		return sub.rep->length<=rep->length && !t_memcmp( rep->data+rep->length-sub.rep->length,sub.rep->data,sub.rep->length );
	}
	
	String Slice( int from,int term )const{
		int len=rep->length;
		if( from<0 ){
			from+=len;
			if( from<0 ) from=0;
		}else if( from>len ){
			from=len;
		}
		if( term<0 ){
			term+=len;
		}else if( term>len ){
			term=len;
		}
		if( term<from ) return String();
		if( from==0 && term==len ) return *this;
		return String( rep->data+from,term-from );
	}

	String Slice( int from )const{
		return Slice( from,rep->length );
	}
	
	int ToInt()const{
		return atoi( ToCString<char>() );
	}
	
	Float ToFloat()const{
		return atof( ToCString<char>() );
	}
	
	template<class C> C *ToCString()const{

		C *p=&Array<C>( rep->length+1 )[0];
		
		for( int i=0;i<rep->length;++i ) p[i]=rep->data[i];
		p[rep->length]=0;
		return p;
	}

#if __OBJC__	
	NSString *ToNSString()const{
		return [NSString stringWithCharacters:ToCString<unichar>() length:rep->length];
	}
#endif

	bool Save( FILE *fp ){
		std::vector<unsigned char> buf;
		Save( buf );
		return fwrite( &buf[0],1,buf.size(),fp )==buf.size();
	}
	
	void Save( std::vector<unsigned char> &buf ){
	
		bool uni=false;
		
		for( int i=0;i<rep->length;++i ){
			if( rep->data[i]>=0xfe ){
				uni=true;
				break;
			}
		}
		
		if( uni ){
			Char c;
			unsigned char *p=(unsigned char*)&c;
			c=0xfeff;
			buf.push_back( p[0] );
			buf.push_back( p[1] );
			for( int i=0;i<rep->length;++i ){
				c=rep->data[i];
				buf.push_back( p[0] );
				buf.push_back( p[1] );
			}
		}else{
			for( int i=0;i<rep->length;++i ){
				buf.push_back( rep->data[i] );
			}
		}
	}
	
	static String FromChars( Array<int> chars ){
		int n=chars.Length();
		Rep *p=Rep::alloc( n );
		for( int i=0;i<n;++i ){
			p->data[i]=chars[i];
		}
		return String( p );
	}

	static String Load( FILE *fp ){
		unsigned char tmp[4096];
		std::vector<unsigned char> buf;
		for(;;){
			int n=fread( tmp,1,4096,fp );
			if( n>0 ) buf.insert( buf.end(),tmp,tmp+n );
			if( n!=4096 ) break;
		}
		return String::Load( &buf[0],buf.size() );
	}
	
	static String Load( unsigned char *p,int n ){
	
		if( n<3 ) return String( p,n );
		
		unsigned char *term=p+n;
		std::vector<Char> chars;

		int c=*p++;
		int d=*p++;
		
		if( c==0xfe && d==0xff ){
			while( p<term-1 ){
				int c=*p++;
				chars.push_back( (c<<8)|*p++ );
			}
		}else if( c==0xff && d==0xfe ){
			while( p<term-1 ){
				int c=*p++;
				chars.push_back( (*p++<<8)|c );
			}
		}else{
			int e=*p++;
			if( c!=0xef || d!=0xbb || e!=0xbf ) return String( p-3,n );
			while( p<term ){
				int c=*p++;
				if( c>=128 && p<term ){
					int d=*p++;
					if( c>=224 && p<term ){
						int e=*p++;
						if( c>=240 ) break;	//Illegal UTF8!
						c=(c-224)*4096+(d-128)*64+(e-128);
					}else{
						c=(c-192)*64+(d-128);
					}
				}
				chars.push_back( c );
			}
		}
		return String( &chars[0],chars.size() );
	}
	
private:
	struct Rep{
		int refs;
		int length;
		Char data[0];
		
		Rep( int length ):refs(1),length(length){
		}
		
		void retain(){
			++refs;
		}
		
		void release(){
			if( --refs || !length ) return;
			free( this );
		}

		static Rep *alloc( int length ){
			if( !length ){
				static Rep null(0);
				return &null;
			}
			void *p=malloc( sizeof(Rep)+length*sizeof(Char) );
			return new(p) Rep( length );
		}
	};
	Rep *rep;
	
	String( Rep *rep ):rep(rep){
	}
};

String *t_create( int n,String *p ){
	for( int i=0;i<n;++i ) new( &p[i] ) String();
	return p+n;
}

String *t_create( int n,String *p,const String *q ){
	for( int i=0;i<n;++i ) new( &p[i] ) String( q[i] );
	return p+n;
}

void t_destroy( int n,String *p ){
	for( int i=0;i<n;++i ) p[i].~String();
}

String T( const char *p ){
	return String( p );
}

String T( const wchar_t *p ){
	return String( p );
}

// ***** Object *****

class Object : public gc_object{
public:
	virtual bool Equals( Object *obj ){
		return this==obj;
	}
	
	virtual int Compare( Object *obj ){
		return (char*)this-(char*)obj;
	}
};

//Some ugly hacks for interfaces in an attempt to keep plain objects speedy.
//
//This mess is mainly to prevent classes from having to virtually inherit 'Object', which incurs quite a
//bit of overhead when upcasting to Object.
//
struct gc_interface{
	virtual ~gc_interface(){}
	
//	gc_object *to_object(){ return dynamic_cast<gc_object*>(this) );
};

template<class T>
struct gc_iptr{
	T *p;
	gc_iptr(){}
	gc_iptr( T *p ):p(p){} 
};

template<class T> void gc_mark( gc_iptr<T> i ){
	gc_mark( dynamic_cast<gc_object*>(i.p) );
}

template<class T> void gc_mark_q( gc_iptr<T> i ){
	gc_mark_q( dynamic_cast<gc_object*>(i.p) );
}

//mark array of iptrs
template<class T> void gc_mark_array( int n,gc_iptr<T> *p ){
	for( int i=0;i<n;++i ) gc_mark( dynamic_cast<gc_object*>( p[i].p ) );
}

#if CFG_CPP_INCREMENTAL_GC

//template<class T,class V> void gc_assign( gc_iptr<T> *lhs,V *rhs ){
//	gc_mark_q( dynamic_cast<gc_object*>( rhs ) );
//	lhs->p=rhs;
//}

#endif

//**** main ****

int argc;
const char **argv;
const char *errInfo="";
std::vector<const char*> errStack;

Float D2R=0.017453292519943295f;
Float R2D=57.29577951308232f;

void pushErr(){
	errStack.push_back( errInfo );
}

void popErr(){
	errInfo=errStack.back();
	errStack.pop_back();
}

String StackTrace(){
	String str;
	pushErr();
	for( int i=errStack.size()-1;i>=0;--i ){
		str+=String( errStack[i] )+"\n";
	}
	popErr();
	return str;
}

int Print( String t ){
	puts( t.ToCString<char>() );
	fflush( stdout );
	return 0;
}

int Error( String err ){
	throw err.ToCString<char>();
	return 0;
}

int Compare( int x,int y ){
	return x-y;
}

int Compare( Float x,Float y ){
	return x<y ? -1 : x>y;
}

int Compare( String x,String y ){
	return x.Compare( y );
}

int bbInit();
int bbMain();

#if _MSC_VER

//Ok, this is butt ugly stuff, but MSVC's SEH seems to be the only
//way you can catch int divide by zero...let's use it for null objects too...
//
const char *FilterException( int type ){
	switch( type ){
	case STATUS_ACCESS_VIOLATION:return "Memory access violation";
	case STATUS_INTEGER_DIVIDE_BY_ZERO:return "Integer divide by zero";
	}
	return 0;
}

int seh_call( int(*f)() ){
	const char *p;
	__try{
		return f();
	}__except( (p=FilterException(GetExceptionCode()))!=0 ){
		puts( p );
		throw p;
	}
}

#else

int seh_call( int(*f)() ){
	return f();
}

void sighandler( int sig  ){
	switch( sig ){
	case SIGILL:throw "Illegal instruction";
	case SIGFPE:throw "Floating point exception";
#if !_WIN32
	case SIGBUS:throw "Bus error";
#endif
	case SIGSEGV:throw "Segmentation violation";
	}
	throw "Unknown exception";
}

#endif

//entry point call by target main()...
//
int bb_std_main( int argc,const char **argv ){
	
	::argc=argc;
	::argv=argv;
	
#if !_MSC_VER
	signal( SIGILL,sighandler );
	signal( SIGFPE,sighandler );
#if !_WIN32
	signal( SIGBUS,sighandler );
#endif
	signal( SIGSEGV,sighandler );
#endif

	P_START
	
	seh_call( bbInit );
	
#if CFG_CPP_INCREMENTAL_GC
	gc_mark_roots();
#endif
	
	seh_call( bbMain );
	
	P_STOP
	
	return 0;
}

// Stdcpp trans.system runtime.
//
// Placed into the public domain 24/02/2011.
// No warranty implied; use as your own risk.

#if _WIN32

/*
#include <windows.h>
#include <direct.h>
#include <sys/stat.h>
*/

#ifndef PATH_MAX
#define PATH_MAX MAX_PATH
#endif

typedef wchar_t OS_CHAR;
typedef struct _stat stat_t;

#define mkdir( X,Y ) _wmkdir( X )
#define rmdir _wrmdir
#define remove _wremove
#define rename _wrename
#define stat _wstat
#define _fopen _wfopen
#define putenv _wputenv
#define getenv _wgetenv
#define system _wsystem
#define chdir _wchdir
#define getcwd _wgetcwd
#define realpath(X,Y) _wfullpath( Y,X,PATH_MAX )	//Note: first args SWAPPED to be posix-like!
#define opendir _wopendir
#define readdir _wreaddir
#define closedir _wclosedir
#define DIR _WDIR
#define dirent _wdirent

#elif __APPLE__

/*
#include <mach-o/dyld.h>
#include <sys/stat.h>
#include <dirent.h>
#include <copyfile.h>
*/

typedef char OS_CHAR;
typedef struct stat stat_t;

#define _fopen fopen

#elif __linux

/*
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
*/

typedef char OS_CHAR;
typedef struct stat stat_t;

#define _fopen fopen

#endif

static String _appPath;
static Array<String> _appArgs;

static char *C_STR( const String &t ){
	return t.ToCString<char>();
}

static OS_CHAR *OS_STR( const String &t ){
	return t.ToCString<OS_CHAR>();
}

String HostOS(){
#if _WIN32
	return "winnt";
#elif __APPLE__
	return "macos";
#elif __linux
	return "linux";
#else
	return "";
#endif
}

String RealPath( String path ){
	std::vector<OS_CHAR> buf( PATH_MAX+1 );
	realpath( OS_STR( path ),&buf[0] );
	buf[buf.size()-1]=0;
	for( int i=0;i<PATH_MAX && buf[i];++i ){
		if( buf[i]=='\\' ) buf[i]='/';
		
	}
	return String( &buf[0] );
}

String AppPath(){

	if( _appPath.Length() ) return _appPath;
	
#if _WIN32

	OS_CHAR buf[PATH_MAX+1];
	GetModuleFileNameW( GetModuleHandleW(0),buf,PATH_MAX );
	buf[PATH_MAX]=0;
	_appPath=String( buf );
	
#elif __APPLE__

	char buf[PATH_MAX];
	uint32_t size=sizeof( buf );
	_NSGetExecutablePath( buf,&size );
	buf[PATH_MAX-1]=0;
	_appPath=String( buf );
	
#elif __linux

	char lnk[PATH_MAX],buf[PATH_MAX];
	pid_t pid=getpid();
	sprintf( lnk,"/proc/%i/exe",pid );
	int i=readlink( lnk,buf,PATH_MAX );
	if( i>0 && i<PATH_MAX ){
		buf[i]=0;
		_appPath=String( buf );
	}

#endif

	_appPath=RealPath( _appPath );
	return _appPath;
}

Array<String> AppArgs(){
	if( _appArgs.Length() ) return _appArgs;
	_appArgs=Array<String>( argc );
	for( int i=0;i<argc;++i ){
		_appArgs[i]=String( argv[i] );
	}
	return _appArgs;
}
	
int FileType( String path ){
	stat_t st;
	if( stat( OS_STR(path),&st ) ) return 0;
	switch( st.st_mode & S_IFMT ){
	case S_IFREG : return 1;
	case S_IFDIR : return 2;
	}
	return 0;
}

int FileSize( String path ){
	stat_t st;
	if( stat( OS_STR(path),&st ) ) return -1;
	return st.st_size;
}

int FileTime( String path ){
	stat_t st;
	if( stat( OS_STR(path),&st ) ) return -1;
	return st.st_mtime;
}

String LoadString( String path ){
	if( FILE *fp=_fopen( OS_STR(path),OS_STR("rb") ) ){
		String str=String::Load( fp );
		fclose( fp );
		return str;
	}
	printf( "FOPEN 'rb' for LoadString '%s' failed\n",C_STR( path ) );fflush( stdout );
	return "";
}
	
int SaveString( String str,String path ){
	if( FILE *fp=_fopen( OS_STR(path),OS_STR("wb") ) ){
		bool ok=str.Save( fp );
		fclose( fp );
		return ok ? 0 : -2;
	}else{
		printf( "FOPEN 'wb' for SaveString '%s' failed\n",C_STR( path ) );
		fflush( stdout );
	}
	return -1;
}

Array<String> LoadDir( String path ){
	std::vector<String> files;
	
#if _WIN32

	WIN32_FIND_DATAW filedata;
	HANDLE handle=FindFirstFileW( OS_STR(path+"/*"),&filedata );
	if( handle!=INVALID_HANDLE_VALUE ){
		do{
			String f=filedata.cFileName;
			if( f=="." || f==".." ) continue;
			files.push_back( f );
		}while( FindNextFileW( handle,&filedata ) );
		FindClose( handle );
	}else{
		printf( "FindFirstFileW for LoadDir(%s) failed\n",C_STR(path) );
		fflush( stdout );
	}
	
#else

	if( DIR *dir=opendir( OS_STR(path) ) ){
		while( dirent *ent=readdir( dir ) ){
			String f=ent->d_name;
			if( f=="." || f==".." ) continue;
			files.push_back( f );
		}
		closedir( dir );
	}else{
		printf( "opendir for LoadDir(%s) failed\n",C_STR(path) );
		fflush( stdout );
	}

#endif

	return Array<String>( &files[0],files.size() );
}
	
int CopyFile( String srcpath,String dstpath ){

#if _WIN32

	if( CopyFileW( OS_STR(srcpath),OS_STR(dstpath),FALSE ) ) return 1;
	return 0;
	
#elif __APPLE__

	// Would like to use COPY_ALL here, but it breaks trans on MacOS - produces weird 'pch out of date' error with copied projects.
	//
	// Ranlib strikes back!
	//
	if( copyfile( OS_STR(srcpath),OS_STR(dstpath),0,COPYFILE_DATA )>=0 ) return 1;
	return 0;
	
#else

	int err=-1;
	if( FILE *srcp=_fopen( OS_STR( srcpath ),OS_STR( T("rb") ) ) ){
		err=-2;
		if( FILE *dstp=_fopen( OS_STR( dstpath ),OS_STR( T("wb") ) ) ){
			err=0;
			char buf[1024];
			while( int n=fread( buf,1,1024,srcp ) ){
				if( fwrite( buf,1,n,dstp )!=n ){
					err=-3;
					break;
				}
			}
			fclose( dstp );
		}else{
			printf( "FOPEN 'wb' for CopyFile(%s,%s) failed\n",C_STR(srcpath),C_STR(dstpath) );
			fflush( stdout );
		}
		fclose( srcp );
	}else{
		printf( "FOPEN 'rb' for CopyFile(%s,%s) failed\n",C_STR(srcpath),C_STR(dstpath) );
		fflush( stdout );
	}
	return err==0;
	
#endif
}

int ChangeDir( String path ){
	return chdir( OS_STR(path) );
}

String CurrentDir(){
	std::vector<OS_CHAR> buf( PATH_MAX+1 );
	getcwd( &buf[0],buf.size() );
	buf[buf.size()-1]=0;
	return String( &buf[0] );
}

int CreateDir( String path ){
	mkdir( OS_STR( path ),0777 );
	return FileType(path)==2;
}

int DeleteDir( String path ){
	rmdir( OS_STR(path) );
	return FileType(path)==0;
}

int DeleteFile( String path ){
	remove( OS_STR(path) );
	return FileType(path)==0;
}

int SetEnv( String name,String value ){
	return putenv( OS_STR( String(name)+T("=")+String(value) ) );
}

String GetEnv( String name ){
	if( OS_CHAR *p=getenv( OS_STR(name) ) ) return String( p );
	return T("");
}

int Execute( String cmd ){

#if _WIN32

	cmd=T("cmd /S /C \"")+cmd+T("\"");

	PROCESS_INFORMATION pi={0};
	STARTUPINFOW si={sizeof(si)};

	if( !CreateProcessW( 0,(WCHAR*)OS_STR(cmd),0,0,1,0,0,0,&si,&pi ) ) return -1;

	WaitForSingleObject( pi.hProcess,INFINITE );

	int res=GetExitCodeProcess( pi.hProcess,(DWORD*)&res ) ? res : -1;

	CloseHandle( pi.hProcess );
	CloseHandle( pi.hThread );

	return res;

#else

	return system( OS_STR(cmd) );

#endif
}

int ExitApp( int retcode ){
	exit( retcode );
	return 0;
}
class bb_template_parser_Replacer;
class bb_list_List;
class bb_list_Node;
class bb_list_HeadNode;
class bb_list_List2;
class bb_list_Node2;
class bb_list_HeadNode2;
class bb_list_Enumerator;
class bb_list_Enumerator2;
int bb_template_parser_PrintInfoHeader();
String bb_os_StripExt(String);
String bb_os_StripDir(String);
String bb_os_StripAll(String);
String bb_template_parser_GetDir(String);
class bb_template_parser_Replacer : public Object{
	public:
	String f_find;
	String f_replace;
	bb_template_parser_Replacer();
	bb_template_parser_Replacer* g_new();
	void mark();
};
class bb_list_List : public Object{
	public:
	bb_list_Node* f__head;
	bb_list_List();
	bb_list_List* g_new();
	virtual bb_list_Node* m_AddLast(String);
	bb_list_List* g_new2(Array<String >);
	virtual bb_list_Enumerator2* m_ObjectEnumerator();
	void mark();
};
class bb_list_Node : public Object{
	public:
	bb_list_Node* f__succ;
	bb_list_Node* f__pred;
	String f__data;
	bb_list_Node();
	bb_list_Node* g_new(bb_list_Node*,bb_list_Node*,String);
	bb_list_Node* g_new2();
	void mark();
};
class bb_list_HeadNode : public bb_list_Node{
	public:
	bb_list_HeadNode();
	bb_list_HeadNode* g_new();
	void mark();
};
class bb_list_List2 : public Object{
	public:
	bb_list_Node2* f__head;
	bb_list_List2();
	bb_list_List2* g_new();
	virtual bb_list_Node2* m_AddLast2(bb_template_parser_Replacer*);
	bb_list_List2* g_new2(Array<bb_template_parser_Replacer* >);
	virtual int m_Count();
	virtual bb_list_Enumerator* m_ObjectEnumerator();
	virtual Array<bb_template_parser_Replacer* > m_ToArray();
	void mark();
};
class bb_list_Node2 : public Object{
	public:
	bb_list_Node2* f__succ;
	bb_list_Node2* f__pred;
	bb_template_parser_Replacer* f__data;
	bb_list_Node2();
	bb_list_Node2* g_new(bb_list_Node2*,bb_list_Node2*,bb_template_parser_Replacer*);
	bb_list_Node2* g_new2();
	void mark();
};
class bb_list_HeadNode2 : public bb_list_Node2{
	public:
	bb_list_HeadNode2();
	bb_list_HeadNode2* g_new();
	void mark();
};
class bb_list_Enumerator : public Object{
	public:
	bb_list_List2* f__list;
	bb_list_Node2* f__curr;
	bb_list_Enumerator();
	bb_list_Enumerator* g_new(bb_list_List2*);
	bb_list_Enumerator* g_new2();
	virtual bool m_HasNext();
	virtual bb_template_parser_Replacer* m_NextObject();
	void mark();
};
String bb_template_parser_ParseDoc(String,String);
class bb_list_Enumerator2 : public Object{
	public:
	bb_list_List* f__list;
	bb_list_Node* f__curr;
	bb_list_Enumerator2();
	bb_list_Enumerator2* g_new(bb_list_List*);
	bb_list_Enumerator2* g_new2();
	virtual bool m_HasNext();
	virtual String m_NextObject();
	void mark();
};
String bb_template_parser_ParseDoc2(String,Array<bb_template_parser_Replacer* >,String);
int bbMain();
int bb_template_parser_PrintInfoHeader(){
	pushErr();
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<33>";
	Print(String(L"Monkey template parser for the Harpl source code."));
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<34>";
	Print(String(L"This is a simple parser app, pass the file to be pre-compiled as the first paramter, and you're good to go!"));
	popErr();
	return 0;
}
String bb_os_StripExt(String t_path){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/os/os.monkey<138>";
	int t_i=t_path.FindLast(String(L"."));
	errInfo="C:/MonkeyPro54/modules/os/os.monkey<139>";
	if(t_i!=-1 && t_path.Find(String(L"/"),t_i+1)==-1 && t_path.Find(String(L"\\"),t_i+1)==-1){
		errInfo="C:/MonkeyPro54/modules/os/os.monkey<139>";
		String t_=t_path.Slice(0,t_i);
		popErr();
		return t_;
	}
	errInfo="C:/MonkeyPro54/modules/os/os.monkey<140>";
	popErr();
	return t_path;
}
String bb_os_StripDir(String t_path){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/os/os.monkey<125>";
	int t_i=t_path.FindLast(String(L"/"));
	errInfo="C:/MonkeyPro54/modules/os/os.monkey<126>";
	if(t_i==-1){
		errInfo="C:/MonkeyPro54/modules/os/os.monkey<126>";
		t_i=t_path.FindLast(String(L"\\"));
	}
	errInfo="C:/MonkeyPro54/modules/os/os.monkey<127>";
	if(t_i!=-1){
		errInfo="C:/MonkeyPro54/modules/os/os.monkey<127>";
		String t_=t_path.Slice(t_i+1);
		popErr();
		return t_;
	}
	errInfo="C:/MonkeyPro54/modules/os/os.monkey<128>";
	popErr();
	return t_path;
}
String bb_os_StripAll(String t_path){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/os/os.monkey<150>";
	String t_=bb_os_StripDir(bb_os_StripExt(t_path));
	popErr();
	return t_;
}
String bb_template_parser_GetDir(String t_filename){
	pushErr();
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<42>";
	t_filename=t_filename.Replace(String(L"/"),String(L"\\"));
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<43>";
	int t_lastIndex=t_filename.FindLast(String(L"\\"));
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<44>";
	String t_=t_filename.Slice(0,t_lastIndex+1);
	popErr();
	return t_;
}
bb_template_parser_Replacer::bb_template_parser_Replacer(){
	f_find=String();
	f_replace=String();
}
bb_template_parser_Replacer* bb_template_parser_Replacer::g_new(){
	pushErr();
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<90>";
	popErr();
	return this;
}
void bb_template_parser_Replacer::mark(){
	Object::mark();
}
bb_list_List::bb_list_List(){
	f__head=((new bb_list_HeadNode)->g_new());
}
bb_list_List* bb_list_List::g_new(){
	pushErr();
	popErr();
	return this;
}
bb_list_Node* bb_list_List::m_AddLast(String t_data){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<120>";
	bb_list_Node* t_=(new bb_list_Node)->g_new(f__head,f__head->f__pred,t_data);
	popErr();
	return t_;
}
bb_list_List* bb_list_List::g_new2(Array<String > t_data){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	Array<String > t_=t_data;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	int t_2=0;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	while(t_2<t_.Length()){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
		String t_t=t_.At(t_2);
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
		t_2=t_2+1;
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<14>";
		m_AddLast(t_t);
	}
	popErr();
	return this;
}
bb_list_Enumerator2* bb_list_List::m_ObjectEnumerator(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<124>";
	bb_list_Enumerator2* t_=(new bb_list_Enumerator2)->g_new(this);
	popErr();
	return t_;
}
void bb_list_List::mark(){
	Object::mark();
	gc_mark_q(f__head);
}
bb_list_Node::bb_list_Node(){
	f__succ=0;
	f__pred=0;
	f__data=String();
}
bb_list_Node* bb_list_Node::g_new(bb_list_Node* t_succ,bb_list_Node* t_pred,String t_data){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<199>";
	gc_assign(f__succ,t_succ);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<200>";
	gc_assign(f__pred,t_pred);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<201>";
	gc_assign(f__succ->f__pred,this);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<202>";
	gc_assign(f__pred->f__succ,this);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<203>";
	f__data=t_data;
	popErr();
	return this;
}
bb_list_Node* bb_list_Node::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<196>";
	popErr();
	return this;
}
void bb_list_Node::mark(){
	Object::mark();
	gc_mark_q(f__succ);
	gc_mark_q(f__pred);
}
bb_list_HeadNode::bb_list_HeadNode(){
}
bb_list_HeadNode* bb_list_HeadNode::g_new(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<248>";
	bb_list_Node::g_new2();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<249>";
	gc_assign(f__succ,(this));
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<250>";
	gc_assign(f__pred,(this));
	popErr();
	return this;
}
void bb_list_HeadNode::mark(){
	bb_list_Node::mark();
}
bb_list_List2::bb_list_List2(){
	f__head=((new bb_list_HeadNode2)->g_new());
}
bb_list_List2* bb_list_List2::g_new(){
	pushErr();
	popErr();
	return this;
}
bb_list_Node2* bb_list_List2::m_AddLast2(bb_template_parser_Replacer* t_data){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<120>";
	bb_list_Node2* t_=(new bb_list_Node2)->g_new(f__head,f__head->f__pred,t_data);
	popErr();
	return t_;
}
bb_list_List2* bb_list_List2::g_new2(Array<bb_template_parser_Replacer* > t_data){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	Array<bb_template_parser_Replacer* > t_=t_data;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	int t_2=0;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
	while(t_2<t_.Length()){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
		bb_template_parser_Replacer* t_t=t_.At(t_2);
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<13>";
		t_2=t_2+1;
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<14>";
		m_AddLast2(t_t);
	}
	popErr();
	return this;
}
int bb_list_List2::m_Count(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<41>";
	int t_n=0;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<41>";
	bb_list_Node2* t_node=f__head->f__succ;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<42>";
	while(t_node!=f__head){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<43>";
		t_node=t_node->f__succ;
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<44>";
		t_n+=1;
	}
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<46>";
	popErr();
	return t_n;
}
bb_list_Enumerator* bb_list_List2::m_ObjectEnumerator(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<124>";
	bb_list_Enumerator* t_=(new bb_list_Enumerator)->g_new(this);
	popErr();
	return t_;
}
Array<bb_template_parser_Replacer* > bb_list_List2::m_ToArray(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<19>";
	Array<bb_template_parser_Replacer* > t_arr=Array<bb_template_parser_Replacer* >(m_Count());
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<19>";
	int t_i=0;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<20>";
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<20>";
	bb_list_Enumerator* t_=this->m_ObjectEnumerator();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<20>";
	while(t_->m_HasNext()){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<20>";
		bb_template_parser_Replacer* t_t=t_->m_NextObject();
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<21>";
		gc_assign(t_arr.At(t_i),t_t);
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<22>";
		t_i+=1;
	}
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<24>";
	popErr();
	return t_arr;
}
void bb_list_List2::mark(){
	Object::mark();
	gc_mark_q(f__head);
}
bb_list_Node2::bb_list_Node2(){
	f__succ=0;
	f__pred=0;
	f__data=0;
}
bb_list_Node2* bb_list_Node2::g_new(bb_list_Node2* t_succ,bb_list_Node2* t_pred,bb_template_parser_Replacer* t_data){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<199>";
	gc_assign(f__succ,t_succ);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<200>";
	gc_assign(f__pred,t_pred);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<201>";
	gc_assign(f__succ->f__pred,this);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<202>";
	gc_assign(f__pred->f__succ,this);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<203>";
	gc_assign(f__data,t_data);
	popErr();
	return this;
}
bb_list_Node2* bb_list_Node2::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<196>";
	popErr();
	return this;
}
void bb_list_Node2::mark(){
	Object::mark();
	gc_mark_q(f__succ);
	gc_mark_q(f__pred);
	gc_mark_q(f__data);
}
bb_list_HeadNode2::bb_list_HeadNode2(){
}
bb_list_HeadNode2* bb_list_HeadNode2::g_new(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<248>";
	bb_list_Node2::g_new2();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<249>";
	gc_assign(f__succ,(this));
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<250>";
	gc_assign(f__pred,(this));
	popErr();
	return this;
}
void bb_list_HeadNode2::mark(){
	bb_list_Node2::mark();
}
bb_list_Enumerator::bb_list_Enumerator(){
	f__list=0;
	f__curr=0;
}
bb_list_Enumerator* bb_list_Enumerator::g_new(bb_list_List2* t_list){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<264>";
	gc_assign(f__list,t_list);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<265>";
	gc_assign(f__curr,t_list->f__head->f__succ);
	popErr();
	return this;
}
bb_list_Enumerator* bb_list_Enumerator::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<261>";
	popErr();
	return this;
}
bool bb_list_Enumerator::m_HasNext(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<269>";
	while(f__curr->f__succ->f__pred!=f__curr){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<270>";
		gc_assign(f__curr,f__curr->f__succ);
	}
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<272>";
	bool t_=f__curr!=f__list->f__head;
	popErr();
	return t_;
}
bb_template_parser_Replacer* bb_list_Enumerator::m_NextObject(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<276>";
	bb_template_parser_Replacer* t_data=f__curr->f__data;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<277>";
	gc_assign(f__curr,f__curr->f__succ);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<278>";
	popErr();
	return t_data;
}
void bb_list_Enumerator::mark(){
	Object::mark();
	gc_mark_q(f__list);
	gc_mark_q(f__curr);
}
String bb_template_parser_ParseDoc(String t_text,String t_fileLocation){
	pushErr();
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<96>";
	String t_=bb_template_parser_ParseDoc2(t_text,Array<bb_template_parser_Replacer* >(),t_fileLocation);
	popErr();
	return t_;
}
bb_list_Enumerator2::bb_list_Enumerator2(){
	f__list=0;
	f__curr=0;
}
bb_list_Enumerator2* bb_list_Enumerator2::g_new(bb_list_List* t_list){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<264>";
	gc_assign(f__list,t_list);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<265>";
	gc_assign(f__curr,t_list->f__head->f__succ);
	popErr();
	return this;
}
bb_list_Enumerator2* bb_list_Enumerator2::g_new2(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<261>";
	popErr();
	return this;
}
bool bb_list_Enumerator2::m_HasNext(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<269>";
	while(f__curr->f__succ->f__pred!=f__curr){
		errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<270>";
		gc_assign(f__curr,f__curr->f__succ);
	}
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<272>";
	bool t_=f__curr!=f__list->f__head;
	popErr();
	return t_;
}
String bb_list_Enumerator2::m_NextObject(){
	pushErr();
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<276>";
	String t_data=f__curr->f__data;
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<277>";
	gc_assign(f__curr,f__curr->f__succ);
	errInfo="C:/MonkeyPro54/modules/monkey/list.monkey<278>";
	popErr();
	return t_data;
}
void bb_list_Enumerator2::mark(){
	Object::mark();
	gc_mark_q(f__list);
	gc_mark_q(f__curr);
}
String bb_template_parser_ParseDoc2(String t_text,Array<bb_template_parser_Replacer* > t_replaces,String t_fileLocation){
	pushErr();
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<48>";
	Array<String > t_lines=t_text.Split(String(L"\n"));
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<49>";
	bb_list_List* t_lines2=(new bb_list_List)->g_new();
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<50>";
	int t_ignore=0;
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<51>";
	for(int t_i=0;t_i<t_lines.Length();t_i=t_i+1){
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<52>";
		String t_teststring=t_lines.At(t_i).Trim();
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<53>";
		if(t_teststring.ToLower().StartsWith(String(L"'loadtemplate ")) && t_ignore==0){
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<54>";
			Print(String(L"Template load requested!"));
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<55>";
			t_lines2->m_AddLast(t_lines.At(t_i));
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<56>";
			Array<String > t_data=t_teststring.Split(String(L","));
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<57>";
			bb_list_List2* t_repList=(new bb_list_List2)->g_new();
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<58>";
			for(int t_i2=1;t_i2<t_data.Length();t_i2=t_i2+1){
				errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<59>";
				Array<String > t_repData=t_data.At(t_i2).Split(String(L"="));
				errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<60>";
				bb_template_parser_Replacer* t_rep=(new bb_template_parser_Replacer)->g_new();
				errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<61>";
				if(t_repData.Length()==2){
					errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<62>";
					t_rep->f_find=t_repData.At(0);
					errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<63>";
					t_rep->f_replace=t_repData.At(1);
					errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<64>";
					t_repList->m_AddLast2(t_rep);
				}
			}
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<67>";
			Array<bb_template_parser_Replacer* > t_repArray=t_repList->m_ToArray();
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<68>";
			String t_filelocation=RealPath(t_fileLocation+t_data.At(0).Slice(14).Trim());
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<69>";
			Print(String(L"Requesting template located at: ")+t_filelocation);
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<70>";
			t_lines2->m_AddLast(bb_template_parser_ParseDoc2(LoadString(t_filelocation),t_repArray,bb_template_parser_GetDir(t_filelocation)));
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<71>";
			t_ignore+=1;
		}else{
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<72>";
			if(t_lines.At(t_i).Trim().ToLower()==String(L"'endtemplate")){
				errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<73>";
				t_ignore-=1;
			}
		}
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<75>";
		if(t_ignore==0){
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<76>";
			String t_line=t_lines.At(t_i);
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<77>";
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<77>";
			Array<bb_template_parser_Replacer* > t_=t_replaces;
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<77>";
			int t_2=0;
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<77>";
			while(t_2<t_.Length()){
				errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<77>";
				bb_template_parser_Replacer* t_rep2=t_.At(t_2);
				errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<77>";
				t_2=t_2+1;
				errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<78>";
				t_line=t_line.Replace(String(L"{%")+t_rep2->f_find.Trim()+String(L"%}"),t_rep2->f_replace.Trim());
			}
			errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<80>";
			t_lines2->m_AddLast(t_line);
		}
	}
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<83>";
	String t_result=String();
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<84>";
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<84>";
	bb_list_Enumerator2* t_3=t_lines2->m_ObjectEnumerator();
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<84>";
	while(t_3->m_HasNext()){
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<84>";
		String t_s=t_3->m_NextObject();
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<85>";
		t_result=t_result+t_s+String(L"\n");
	}
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<87>";
	popErr();
	return t_result;
}
int bbMain(){
	pushErr();
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<3>";
	if(AppArgs().Length()!=2){
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<4>";
		bb_template_parser_PrintInfoHeader();
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<5>";
		Print(String(L"Wrong parameters number."));
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<6>";
		popErr();
		return -1;
	}
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<8>";
	String t_filePath=AppArgs().At(1);
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<10>";
	if(t_filePath.StartsWith(String(L"."))){
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<10>";
		t_filePath=RealPath(t_filePath);
	}
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<12>";
	if(FileType(t_filePath)!=1){
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<13>";
		bb_template_parser_PrintInfoHeader();
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<14>";
		Print(String(L"Wrong file. File was not found or it is not a file."));
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<15>";
		popErr();
		return -1;
	}
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<18>";
	String t_text=LoadString(AppArgs().At(1));
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<19>";
	if(t_text==String()){
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<20>";
		bb_template_parser_PrintInfoHeader();
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<21>";
		Print(String(L"File was empty"));
		errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<22>";
		popErr();
		return -1;
	}
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<25>";
	Print(String(L"Parsing document: ")+bb_os_StripAll(t_filePath));
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<26>";
	Print(String(L"Located at: ")+bb_template_parser_GetDir(t_filePath));
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<27>";
	t_text=bb_template_parser_ParseDoc(t_text,bb_template_parser_GetDir(t_filePath));
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<28>";
	Print(t_text);
	errInfo="C:/harpl-project/MonkeyTemplateParser/template_parser.monkey<29>";
	popErr();
	return 0;
}
int bbInit(){
	return 0;
}
void gc_mark(){
}
//${TRANSCODE_END}

int main( int argc,const char **argv ){

	try{
	
		bb_std_main( argc,argv );
		
	}catch( const char *err ){
	
		Print( String("Monkey runtime error: ")+err+"\n"+StackTrace() );
	}
}
